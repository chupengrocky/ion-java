


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: IonStructLite</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.amazon.ion.impl.lite</a> ]
</div>

<h1>Coverage Summary for Class: IonStructLite (com.amazon.ion.impl.lite)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">IonStructLite</td>
<td class="coverageStat">
  <span class="percent">
    95.3%
  </span>
  <span class="absValue">
    (41/ 43)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.2%
  </span>
  <span class="absValue">
    (276/ 306)
  </span>
</td>
</tr>
  <tr>
    <td class="name">IonStructLite$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonStructLite$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonStructLite$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (16/ 18)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    95.9%
  </span>
  <span class="absValue">
    (47/ 49)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.3%
  </span>
  <span class="absValue">
    (298/ 330)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
<i>3</i>&nbsp; *
<i>4</i>&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
<i>5</i>&nbsp; * You may not use this file except in compliance with the License.
<i>6</i>&nbsp; * A copy of the License is located at
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
<i>9</i>&nbsp; *
<i>10</i>&nbsp; * or in the &quot;license&quot; file accompanying this file. This file is distributed
<i>11</i>&nbsp; * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
<i>12</i>&nbsp; * express or implied. See the License for the specific language governing
<i>13</i>&nbsp; * permissions and limitations under the License.
<i>14</i>&nbsp; */
<i>15</i>&nbsp;
<i>16</i>&nbsp;package com.amazon.ion.impl.lite;
<i>17</i>&nbsp;
<i>18</i>&nbsp;import com.amazon.ion.ContainedValueException;
<i>19</i>&nbsp;import com.amazon.ion.IonStruct;
<i>20</i>&nbsp;import com.amazon.ion.IonType;
<i>21</i>&nbsp;import com.amazon.ion.IonValue;
<i>22</i>&nbsp;import com.amazon.ion.IonWriter;
<i>23</i>&nbsp;import com.amazon.ion.SymbolToken;
<i>24</i>&nbsp;import com.amazon.ion.ValueFactory;
<i>25</i>&nbsp;import com.amazon.ion.ValueVisitor;
<i>26</i>&nbsp;import com.amazon.ion.impl._Private_CurriedValueFactory;
<i>27</i>&nbsp;import com.amazon.ion.util.Equivalence;
<i>28</i>&nbsp;import com.amazon.ion.UnknownSymbolException;
<i>29</i>&nbsp;import java.io.IOException;
<i>30</i>&nbsp;import java.io.PrintWriter;
<i>31</i>&nbsp;import java.util.Arrays;
<i>32</i>&nbsp;import java.util.HashMap;
<i>33</i>&nbsp;import java.util.HashSet;
<i>34</i>&nbsp;import java.util.Iterator;
<i>35</i>&nbsp;import java.util.ListIterator;
<i>36</i>&nbsp;import java.util.Map;
<i>37</i>&nbsp;import java.util.Map.Entry;
<i>38</i>&nbsp;import java.util.Set;
<i>39</i>&nbsp;
<i>40</i>&nbsp;
<b class="fc"><i>41</i>&nbsp;final class IonStructLite</b>
<i>42</i>&nbsp;    extends IonContainerLite
<i>43</i>&nbsp;    implements IonStruct
<i>44</i>&nbsp;{
<b class="fc"><i>45</i>&nbsp;    private static final int HASH_SIGNATURE =</b>
<b class="fc"><i>46</i>&nbsp;        IonType.STRUCT.toString().hashCode();</b>
<i>47</i>&nbsp;    // TODO amzn/ion-java/issues/41: add support for _isOrdered
<i>48</i>&nbsp;
<i>49</i>&nbsp;    IonStructLite(ContainerlessContext context, boolean isNull)
<i>50</i>&nbsp;    {
<b class="fc"><i>51</i>&nbsp;        super(context, isNull);</b>
<b class="fc"><i>52</i>&nbsp;    }</b>
<i>53</i>&nbsp;
<i>54</i>&nbsp;    private IonStructLite(IonStructLite existing, IonContext context)
<i>55</i>&nbsp;    {
<b class="fc"><i>56</i>&nbsp;        super(existing, context, true);</b>
<i>57</i>&nbsp;        // field map can be shallow cloned due to it dealing with String and Integer
<i>58</i>&nbsp;        // values - both of which are immutable constructs and so safe to retain as references
<b class="fc"><i>59</i>&nbsp;        this._field_map = null == existing._field_map ? null : new HashMap&lt;String, Integer&gt;(existing._field_map);</b>
<b class="fc"><i>60</i>&nbsp;        this._field_map_duplicate_count = existing._field_map_duplicate_count;</b>
<b class="fc"><i>61</i>&nbsp;        this.hasNullFieldName = existing.hasNullFieldName;</b>
<b class="fc"><i>62</i>&nbsp;    }</b>
<i>63</i>&nbsp;
<i>64</i>&nbsp;    private Map&lt;String, Integer&gt; _field_map;
<b class="fc"><i>65</i>&nbsp;    private boolean hasNullFieldName = false;</b>
<i>66</i>&nbsp;
<i>67</i>&nbsp;    public int                      _field_map_duplicate_count;
<i>68</i>&nbsp;
<i>69</i>&nbsp;    @Override
<i>70</i>&nbsp;    IonStructLite clone(IonContext parentContext)
<i>71</i>&nbsp;    {
<b class="fc"><i>72</i>&nbsp;        return new IonStructLite(this, parentContext);</b>
<i>73</i>&nbsp;    }
<i>74</i>&nbsp;
<i>75</i>&nbsp;    @Override
<i>76</i>&nbsp;    public IonStructLite clone()
<i>77</i>&nbsp;    {
<b class="fc"><i>78</i>&nbsp;        return clone(ContainerlessContext.wrap(getSystem()));</b>
<i>79</i>&nbsp;    }
<i>80</i>&nbsp;
<i>81</i>&nbsp;    @Override
<i>82</i>&nbsp;    protected void transitionToLargeSize(int size)
<i>83</i>&nbsp;    {
<b class="fc"><i>84</i>&nbsp;        if (_field_map != null) return;</b>
<i>85</i>&nbsp;
<b class="fc"><i>86</i>&nbsp;        build_field_map();</b>
<b class="fc"><i>87</i>&nbsp;        return;</b>
<i>88</i>&nbsp;    }
<i>89</i>&nbsp;    protected void build_field_map()
<i>90</i>&nbsp;    {
<b class="fc"><i>91</i>&nbsp;        int size = (_children == null) ? 0 : _children.length;</b>
<i>92</i>&nbsp;
<b class="fc"><i>93</i>&nbsp;        _field_map = new HashMap&lt;String, Integer&gt;(size);</b>
<b class="fc"><i>94</i>&nbsp;        _field_map_duplicate_count = 0;</b>
<i>95</i>&nbsp;
<b class="fc"><i>96</i>&nbsp;        int count = get_child_count();</b>
<b class="fc"><i>97</i>&nbsp;        for (int ii=0; ii&lt;count; ii++) {</b>
<b class="fc"><i>98</i>&nbsp;            IonValueLite v = get_child(ii);</b>
<b class="fc"><i>99</i>&nbsp;            SymbolToken fieldNameSymbol = v.getFieldNameSymbol();</b>
<b class="fc"><i>100</i>&nbsp;            String name = fieldNameSymbol.getText();</b>
<b class="fc"><i>101</i>&nbsp;            if (_field_map.get(name) != null) {</b>
<b class="fc"><i>102</i>&nbsp;                _field_map_duplicate_count++;</b>
<i>103</i>&nbsp;            }
<b class="fc"><i>104</i>&nbsp;            _field_map.put(name, ii); // this causes the map to have the largest index value stored</b>
<i>105</i>&nbsp;        }
<b class="fc"><i>106</i>&nbsp;        return;</b>
<i>107</i>&nbsp;    }
<i>108</i>&nbsp;    private void add_field(String fieldName, int newFieldIdx)
<i>109</i>&nbsp;    {
<b class="fc"><i>110</i>&nbsp;        Integer idx = _field_map.get(fieldName);</b>
<b class="fc"><i>111</i>&nbsp;        if (idx != null) {</b>
<b class="fc"><i>112</i>&nbsp;            _field_map_duplicate_count++;</b>
<b class="fc"><i>113</i>&nbsp;            if (idx.intValue() &gt; newFieldIdx) {</b>
<b class="nc"><i>114</i>&nbsp;                newFieldIdx = idx.intValue();</b>
<i>115</i>&nbsp;            }
<i>116</i>&nbsp;        }
<b class="fc"><i>117</i>&nbsp;        _field_map.put(fieldName, newFieldIdx);</b>
<b class="fc"><i>118</i>&nbsp;    }</b>
<i>119</i>&nbsp;    private void remove_field(String fieldName, int lowest_idx, int copies)
<i>120</i>&nbsp;    {
<b class="fc"><i>121</i>&nbsp;        if (_field_map == null) {</b>
<b class="fc"><i>122</i>&nbsp;            return;</b>
<i>123</i>&nbsp;        }
<i>124</i>&nbsp;
<b class="fc"><i>125</i>&nbsp;        Integer field_idx = _field_map.get(fieldName);</b>
<b class="fc"><i>126</i>&nbsp;        assert(field_idx != null);</b>
<b class="fc"><i>127</i>&nbsp;        _field_map.remove(fieldName);</b>
<b class="fc"><i>128</i>&nbsp;        _field_map_duplicate_count -= (copies - 1);</b>
<b class="fc"><i>129</i>&nbsp;    }</b>
<i>130</i>&nbsp;
<i>131</i>&nbsp;    private void remove_field_from_field_map(String fieldName, int idx)
<i>132</i>&nbsp;    {
<b class="fc"><i>133</i>&nbsp;        Integer field_idx = _field_map.get(fieldName);</b>
<b class="fc"><i>134</i>&nbsp;        assert(field_idx != null);</b>
<i>135</i>&nbsp;
<b class="fc"><i>136</i>&nbsp;        if (field_idx.intValue() != idx) {</b>
<i>137</i>&nbsp;            // if the map has a different index, this must
<i>138</i>&nbsp;            // be a duplicate, and this copy isn&#39;t in the map
<b class="fc"><i>139</i>&nbsp;            assert(_field_map_duplicate_count &gt; 0);</b>
<b class="fc"><i>140</i>&nbsp;            _field_map_duplicate_count--;</b>
<i>141</i>&nbsp;        }
<b class="fc"><i>142</i>&nbsp;        else if (_field_map_duplicate_count &gt; 0) {</b>
<i>143</i>&nbsp;            // if we have any duplicates we have to check
<i>144</i>&nbsp;            // every time since we don&#39;t track which field
<i>145</i>&nbsp;            // is duplicated - so any dup can be expensive
<b class="fc"><i>146</i>&nbsp;            int ii = find_last_duplicate(fieldName, idx);</b>
<i>147</i>&nbsp;
<b class="fc"><i>148</i>&nbsp;            if (ii == -1) {</b>
<i>149</i>&nbsp;                // this is the last copy of this key
<b class="fc"><i>150</i>&nbsp;                _field_map.remove(fieldName);</b>
<i>151</i>&nbsp;            }
<i>152</i>&nbsp;            else {
<i>153</i>&nbsp;                // replaces this fields (the one being
<i>154</i>&nbsp;                // removed) array idx in the map with
<i>155</i>&nbsp;                // the preceding duplicates index
<b class="fc"><i>156</i>&nbsp;                _field_map.put(fieldName, ii);</b>
<b class="fc"><i>157</i>&nbsp;                _field_map_duplicate_count--;</b>
<i>158</i>&nbsp;            }
<b class="fc"><i>159</i>&nbsp;        }</b>
<i>160</i>&nbsp;        else {
<i>161</i>&nbsp;            // since there are not dup&#39;s we can just update
<i>162</i>&nbsp;            // the map by removing this fieldname
<b class="fc"><i>163</i>&nbsp;            _field_map.remove(fieldName);</b>
<i>164</i>&nbsp;        }
<b class="fc"><i>165</i>&nbsp;    }</b>
<i>166</i>&nbsp;
<i>167</i>&nbsp;    private void patch_map_elements_helper(int removed_idx)
<i>168</i>&nbsp;    {
<b class="fc"><i>169</i>&nbsp;        if (_field_map == null) {</b>
<b class="fc"><i>170</i>&nbsp;            return;</b>
<i>171</i>&nbsp;        }
<i>172</i>&nbsp;
<b class="fc"><i>173</i>&nbsp;        if (removed_idx &gt;= get_child_count()) {</b>
<i>174</i>&nbsp;            // if this was the at the end of the list
<i>175</i>&nbsp;            // there&#39;s nothing to change
<b class="fc"><i>176</i>&nbsp;            return;</b>
<i>177</i>&nbsp;        }
<i>178</i>&nbsp;
<b class="fc"><i>179</i>&nbsp;        for (int ii=removed_idx; ii&lt;get_child_count(); ii++) {</b>
<b class="fc"><i>180</i>&nbsp;            IonValueLite value = get_child(ii);</b>
<b class="fc"><i>181</i>&nbsp;            String  field_name = value.getFieldName();</b>
<b class="fc"><i>182</i>&nbsp;            Integer map_idx = _field_map.get(field_name);</b>
<b class="fc"><i>183</i>&nbsp;            if (map_idx.intValue() != ii) {</b>
<i>184</i>&nbsp;                // if this is a field that to the right of
<i>185</i>&nbsp;                // the removed (in process of removing) value
<i>186</i>&nbsp;                // we need to patch the index value
<b class="fc"><i>187</i>&nbsp;                _field_map.put(field_name, ii);</b>
<i>188</i>&nbsp;            }
<i>189</i>&nbsp;        }
<b class="fc"><i>190</i>&nbsp;    }</b>
<i>191</i>&nbsp;
<i>192</i>&nbsp;    @Override
<i>193</i>&nbsp;    public void dump(PrintWriter out)
<i>194</i>&nbsp;    {
<b class="nc"><i>195</i>&nbsp;        super.dump(out);</b>
<i>196</i>&nbsp;
<b class="nc"><i>197</i>&nbsp;        if (_field_map == null) {</b>
<b class="nc"><i>198</i>&nbsp;            return;</b>
<i>199</i>&nbsp;        }
<i>200</i>&nbsp;
<b class="nc"><i>201</i>&nbsp;        out.println(&quot;   dups: &quot;+_field_map_duplicate_count);</b>
<b class="nc"><i>202</i>&nbsp;        Iterator&lt;Entry&lt;String, Integer&gt;&gt; it = _field_map.entrySet().iterator();</b>
<b class="nc"><i>203</i>&nbsp;        out.print(&quot;   map: [&quot;);</b>
<b class="nc"><i>204</i>&nbsp;        boolean first = true;</b>
<b class="nc"><i>205</i>&nbsp;        while (it.hasNext()) {</b>
<b class="nc"><i>206</i>&nbsp;            Entry&lt;String, Integer&gt; e = it.next();</b>
<b class="nc"><i>207</i>&nbsp;            if (!first) {</b>
<b class="nc"><i>208</i>&nbsp;                out.print(&quot;,&quot;);</b>
<i>209</i>&nbsp;            }
<b class="nc"><i>210</i>&nbsp;            out.print(e.getKey()+&quot;:&quot;+e.getValue());</b>
<b class="nc"><i>211</i>&nbsp;            first = false;</b>
<b class="nc"><i>212</i>&nbsp;        }</b>
<b class="nc"><i>213</i>&nbsp;        out.println(&quot;]&quot;);</b>
<b class="nc"><i>214</i>&nbsp;    }</b>
<i>215</i>&nbsp;
<i>216</i>&nbsp;    @Override
<i>217</i>&nbsp;    public String validate()
<i>218</i>&nbsp;    {
<b class="nc"><i>219</i>&nbsp;        if (_field_map == null) {</b>
<b class="nc"><i>220</i>&nbsp;            return null;</b>
<i>221</i>&nbsp;        }
<b class="nc"><i>222</i>&nbsp;        String error = &quot;&quot;;</b>
<b class="nc"><i>223</i>&nbsp;        Iterator&lt;Entry&lt;String, Integer&gt;&gt; it = _field_map.entrySet().iterator();</b>
<b class="nc"><i>224</i>&nbsp;        while (it.hasNext()) {</b>
<b class="nc"><i>225</i>&nbsp;            Entry&lt;String, Integer&gt; e = it.next();</b>
<b class="nc"><i>226</i>&nbsp;            int idx = e.getValue().intValue();</b>
<b class="nc"><i>227</i>&nbsp;            IonValueLite v = (idx &gt;= 0 &amp;&amp; idx &lt; get_child_count()) ? get_child(idx) : null;</b>
<b class="nc"><i>228</i>&nbsp;            if (v == null || idx != v._elementid() || (e.getKey().equals(v.getFieldName()) == false)) {</b>
<b class="nc"><i>229</i>&nbsp;                error += &quot;map entry [&quot;+e+&quot;] doesn&#39;t match list value [&quot;+v+&quot;]\n&quot;;</b>
<i>230</i>&nbsp;            }
<b class="nc"><i>231</i>&nbsp;        }</b>
<i>232</i>&nbsp;
<b class="nc"><i>233</i>&nbsp;        return (error == &quot;&quot;) ? null : error;</b>
<i>234</i>&nbsp;    }
<i>235</i>&nbsp;
<i>236</i>&nbsp;    private int find_last_duplicate(String fieldName, int existing_idx)
<i>237</i>&nbsp;    {
<b class="fc"><i>238</i>&nbsp;        for (int ii=existing_idx; ii&gt;0; ) {</b>
<b class="fc"><i>239</i>&nbsp;            ii--;</b>
<b class="fc"><i>240</i>&nbsp;            IonValueLite field = get_child(ii);</b>
<b class="fc"><i>241</i>&nbsp;            if (fieldName.equals(field.getFieldName())) {</b>
<b class="fc"><i>242</i>&nbsp;                return ii;</b>
<i>243</i>&nbsp;            }
<b class="fc"><i>244</i>&nbsp;        }</b>
<b class="fc"><i>245</i>&nbsp;        assert(there_is_only_one(fieldName, existing_idx));</b>
<b class="fc"><i>246</i>&nbsp;        return -1;</b>
<i>247</i>&nbsp;    }
<i>248</i>&nbsp;    private boolean there_is_only_one(String fieldName, int existing_idx)
<i>249</i>&nbsp;    {
<b class="fc"><i>250</i>&nbsp;        int count = 0;</b>
<b class="fc"><i>251</i>&nbsp;        for (int ii=0; ii&lt;get_child_count(); ii++) {</b>
<b class="fc"><i>252</i>&nbsp;            IonValueLite v = get_child(ii);</b>
<b class="fc"><i>253</i>&nbsp;            if (v.getFieldName().equals(fieldName)) {</b>
<b class="fc"><i>254</i>&nbsp;                count++;</b>
<i>255</i>&nbsp;            }
<i>256</i>&nbsp;        }
<b class="fc"><i>257</i>&nbsp;        if (count == 1 || count == 0) {</b>
<b class="fc"><i>258</i>&nbsp;            return true;</b>
<i>259</i>&nbsp;        }
<b class="nc"><i>260</i>&nbsp;        return false;</b>
<i>261</i>&nbsp;    }
<i>262</i>&nbsp;//
<i>263</i>&nbsp;//    updateFieldName is unnecessary since field names are immutable
<i>264</i>&nbsp;//    (except when the value is unattached to any struct)
<i>265</i>&nbsp;//
<i>266</i>&nbsp;//    protected void updateFieldName(String oldname, String name, IonValue field)
<i>267</i>&nbsp;//    {
<i>268</i>&nbsp;//        assert(name != null &amp;&amp; name.equals(field.getFieldName()));
<i>269</i>&nbsp;//
<i>270</i>&nbsp;//        if (oldname == null) return;
<i>271</i>&nbsp;//        if (_field_map == null) return;
<i>272</i>&nbsp;//
<i>273</i>&nbsp;//        Integer idx = _field_map.get(oldname);
<i>274</i>&nbsp;//        if (idx == null) return;
<i>275</i>&nbsp;//
<i>276</i>&nbsp;//        IonValue oldfield = get_child(idx);
<i>277</i>&nbsp;//
<i>278</i>&nbsp;//        // yes, we want object identity in this test
<i>279</i>&nbsp;//        if (oldfield == field) {
<i>280</i>&nbsp;//            remove_field(oldname, idx);
<i>281</i>&nbsp;//            add_field(name, idx);
<i>282</i>&nbsp;//        }
<i>283</i>&nbsp;//    }
<i>284</i>&nbsp;
<i>285</i>&nbsp;    /**
<i>286</i>&nbsp;     * Implements {@link Object#hashCode()} consistent with equals.
<i>287</i>&nbsp;     * This is insensitive to order of fields.
<i>288</i>&nbsp;     * &lt;p&gt;
<i>289</i>&nbsp;     * This method must follow the contract of {@link Object#equals(Object)},
<i>290</i>&nbsp;     * which is located at {@link Equivalence#ionEquals(IonValue, IonValue)}.
<i>291</i>&nbsp;     *
<i>292</i>&nbsp;     * @return  An int, consistent with the contracts for
<i>293</i>&nbsp;     *          {@link Object#hashCode()} and {@link Object#equals(Object)}.
<i>294</i>&nbsp;     */
<i>295</i>&nbsp;    @Override
<i>296</i>&nbsp;    int hashCode(SymbolTableProvider symbolTableProvider)
<i>297</i>&nbsp;    {
<b class="fc"><i>298</i>&nbsp;        final int nameHashSalt  = 16777619; // prime to salt name of each Field</b>
<b class="fc"><i>299</i>&nbsp;        final int valueHashSalt = 8191;     // prime to salt value of each Field</b>
<b class="fc"><i>300</i>&nbsp;        final int sidHashSalt   = 127;      // prime to salt sid of fieldname</b>
<b class="fc"><i>301</i>&nbsp;        final int textHashSalt  = 31;       // prime to salt text of fieldname</b>
<i>302</i>&nbsp;
<b class="fc"><i>303</i>&nbsp;        int result = HASH_SIGNATURE;</b>
<i>304</i>&nbsp;
<b class="fc"><i>305</i>&nbsp;        if (!isNullValue())  {</b>
<b class="fc"><i>306</i>&nbsp;            for (IonValue v : this)  {</b>
<b class="fc"><i>307</i>&nbsp;                IonValueLite vlite = (IonValueLite) v;</b>
<i>308</i>&nbsp;                // If fieldname&#39;s text is unknown, use its sid instead
<b class="fc"><i>309</i>&nbsp;                SymbolToken token = vlite.getFieldNameSymbol(symbolTableProvider);</b>
<b class="fc"><i>310</i>&nbsp;                String text = token.getText();</b>
<i>311</i>&nbsp;
<b class="fc"><i>312</i>&nbsp;                int nameHashCode = text == null</b>
<b class="fc"><i>313</i>&nbsp;                    ? token.getSid()  * sidHashSalt</b>
<b class="fc"><i>314</i>&nbsp;                    : text.hashCode() * textHashSalt;</b>
<i>315</i>&nbsp;
<i>316</i>&nbsp;                // mixing to account for small text and sid deltas
<b class="fc"><i>317</i>&nbsp;                nameHashCode ^= (nameHashCode &lt;&lt; 17) ^ (nameHashCode &gt;&gt; 15);</b>
<i>318</i>&nbsp;
<b class="fc"><i>319</i>&nbsp;                int fieldHashCode = HASH_SIGNATURE;</b>
<b class="fc"><i>320</i>&nbsp;                fieldHashCode = valueHashSalt * fieldHashCode + vlite.hashCode(symbolTableProvider);</b>
<b class="fc"><i>321</i>&nbsp;                fieldHashCode = nameHashSalt  * fieldHashCode + nameHashCode;</b>
<i>322</i>&nbsp;
<i>323</i>&nbsp;                // another mix step for each Field of the struct
<b class="fc"><i>324</i>&nbsp;                fieldHashCode ^= (fieldHashCode &lt;&lt; 19) ^ (fieldHashCode &gt;&gt; 13);</b>
<i>325</i>&nbsp;
<i>326</i>&nbsp;                // Additive hash is used to ensure insensitivity to order of
<i>327</i>&nbsp;                // fields, and will not lose data on value hash codes
<b class="fc"><i>328</i>&nbsp;                result += fieldHashCode;</b>
<b class="fc"><i>329</i>&nbsp;            }</b>
<i>330</i>&nbsp;        }
<i>331</i>&nbsp;
<b class="fc"><i>332</i>&nbsp;        return hashTypeAnnotations(result, symbolTableProvider);</b>
<i>333</i>&nbsp;    }
<i>334</i>&nbsp;
<i>335</i>&nbsp;    public IonStruct cloneAndRemove(String... fieldNames)
<i>336</i>&nbsp;    {
<b class="fc"><i>337</i>&nbsp;        return doClone(false, fieldNames);</b>
<i>338</i>&nbsp;    }
<i>339</i>&nbsp;
<i>340</i>&nbsp;    public IonStruct cloneAndRetain(String... fieldNames)
<i>341</i>&nbsp;    {
<b class="fc"><i>342</i>&nbsp;        return doClone(true, fieldNames);</b>
<i>343</i>&nbsp;    }
<i>344</i>&nbsp;
<i>345</i>&nbsp;    private IonStruct doClone(boolean keep, String... fieldNames)
<i>346</i>&nbsp;    {
<i>347</i>&nbsp;        IonStruct clone;
<b class="fc"><i>348</i>&nbsp;        if (isNullValue())</b>
<i>349</i>&nbsp;        {
<b class="fc"><i>350</i>&nbsp;            clone = getSystem().newNullStruct();</b>
<i>351</i>&nbsp;        }
<i>352</i>&nbsp;        else
<i>353</i>&nbsp;        {
<b class="fc"><i>354</i>&nbsp;            Set&lt;String&gt; fields =</b>
<b class="fc"><i>355</i>&nbsp;                new HashSet&lt;String&gt;(Arrays.asList(fieldNames));</b>
<b class="fc"><i>356</i>&nbsp;            if (keep &amp;&amp; fields.contains(null))</b>
<i>357</i>&nbsp;            {
<b class="fc"><i>358</i>&nbsp;                throw new NullPointerException(&quot;Can&#39;t retain an unknown field name&quot;);</b>
<i>359</i>&nbsp;            }
<i>360</i>&nbsp;
<b class="fc"><i>361</i>&nbsp;            clone = getSystem().newEmptyStruct();</b>
<b class="fc"><i>362</i>&nbsp;            for (IonValue value : this)</b>
<i>363</i>&nbsp;            {
<b class="fc"><i>364</i>&nbsp;                SymbolToken fieldNameSymbol = value.getFieldNameSymbol();</b>
<b class="fc"><i>365</i>&nbsp;                String fieldName = fieldNameSymbol.getText();</b>
<b class="fc"><i>366</i>&nbsp;                if (fields.contains(fieldName) == keep)</b>
<i>367</i>&nbsp;                {
<i>368</i>&nbsp;                    // This ensures that we don&#39;t copy an unknown field name.
<b class="fc"><i>369</i>&nbsp;                    fieldName = value.getFieldName();</b>
<b class="fc"><i>370</i>&nbsp;                    clone.add(fieldName, value.clone());</b>
<i>371</i>&nbsp;                }
<b class="fc"><i>372</i>&nbsp;            }</b>
<i>373</i>&nbsp;        }
<i>374</i>&nbsp;
<b class="fc"><i>375</i>&nbsp;        clone.setTypeAnnotationSymbols(getTypeAnnotationSymbols());</b>
<i>376</i>&nbsp;
<b class="fc"><i>377</i>&nbsp;        return clone;</b>
<i>378</i>&nbsp;    }
<i>379</i>&nbsp;
<i>380</i>&nbsp;
<i>381</i>&nbsp;    @Override
<i>382</i>&nbsp;    public IonType getType()
<i>383</i>&nbsp;    {
<b class="fc"><i>384</i>&nbsp;        return IonType.STRUCT;</b>
<i>385</i>&nbsp;    }
<i>386</i>&nbsp;
<i>387</i>&nbsp;
<i>388</i>&nbsp;    public boolean containsKey(Object fieldName)
<i>389</i>&nbsp;    {
<b class="fc"><i>390</i>&nbsp;        String name = (String) fieldName;</b>
<b class="fc"><i>391</i>&nbsp;        return (null != get(name));</b>
<i>392</i>&nbsp;    }
<i>393</i>&nbsp;
<i>394</i>&nbsp;    public boolean containsValue(Object value)
<i>395</i>&nbsp;    {
<b class="fc"><i>396</i>&nbsp;        IonValue v = (IonValue) value;</b>
<b class="fc"><i>397</i>&nbsp;        return (v.getContainer() == this);</b>
<i>398</i>&nbsp;    }
<i>399</i>&nbsp;
<i>400</i>&nbsp;    public IonValue get(String fieldName)
<i>401</i>&nbsp;    {
<b class="fc"><i>402</i>&nbsp;        int field_idx = find_field_helper(fieldName);</b>
<i>403</i>&nbsp;        IonValue field;
<i>404</i>&nbsp;
<b class="fc"><i>405</i>&nbsp;        if (field_idx &lt; 0) {</b>
<b class="fc"><i>406</i>&nbsp;            if(hasNullFieldName) throw new UnknownSymbolException(&quot;Unable to determine whether the field exists because the struct contains field names with unknown text.&quot;);</b>
<b class="fc"><i>407</i>&nbsp;            field = null;</b>
<i>408</i>&nbsp;        } else {
<b class="fc"><i>409</i>&nbsp;            field = get_child(field_idx);</b>
<i>410</i>&nbsp;        }
<i>411</i>&nbsp;
<b class="fc"><i>412</i>&nbsp;        return field;</b>
<i>413</i>&nbsp;    }
<i>414</i>&nbsp;    private int find_field_helper(String fieldName)
<i>415</i>&nbsp;    {
<b class="fc"><i>416</i>&nbsp;        validateFieldName(fieldName);</b>
<i>417</i>&nbsp;
<b class="fc"><i>418</i>&nbsp;        if (isNullValue()) {</b>
<i>419</i>&nbsp;            // nothing to see here, move along
<i>420</i>&nbsp;        }
<b class="fc"><i>421</i>&nbsp;        else if (_field_map != null) {</b>
<b class="fc"><i>422</i>&nbsp;            Integer idx = _field_map.get(fieldName);</b>
<b class="fc"><i>423</i>&nbsp;            if (idx != null) {</b>
<b class="fc"><i>424</i>&nbsp;                return idx.intValue();</b>
<i>425</i>&nbsp;            }
<b class="fc"><i>426</i>&nbsp;        }</b>
<i>427</i>&nbsp;        else {
<b class="fc"><i>428</i>&nbsp;            int ii, size = get_child_count();</b>
<b class="fc"><i>429</i>&nbsp;            for (ii=0; ii&lt;size; ii++) {</b>
<b class="fc"><i>430</i>&nbsp;                IonValue field = get_child(ii);</b>
<b class="fc"><i>431</i>&nbsp;                if (fieldName.equals(field.getFieldName())) {</b>
<b class="fc"><i>432</i>&nbsp;                    return ii;</b>
<i>433</i>&nbsp;                }
<i>434</i>&nbsp;            }
<i>435</i>&nbsp;        }
<b class="fc"><i>436</i>&nbsp;        return -1;</b>
<i>437</i>&nbsp;    }
<i>438</i>&nbsp;
<i>439</i>&nbsp;    @Override
<i>440</i>&nbsp;    public void clear()
<i>441</i>&nbsp;    {
<b class="fc"><i>442</i>&nbsp;        super.clear();</b>
<b class="fc"><i>443</i>&nbsp;        _field_map = null;</b>
<b class="fc"><i>444</i>&nbsp;        _field_map_duplicate_count = 0;</b>
<b class="fc"><i>445</i>&nbsp;    }</b>
<i>446</i>&nbsp;
<i>447</i>&nbsp;    @Override
<i>448</i>&nbsp;    public boolean add(IonValue child)
<i>449</i>&nbsp;        throws NullPointerException, IllegalArgumentException,
<i>450</i>&nbsp;        ContainedValueException
<i>451</i>&nbsp;    {
<i>452</i>&nbsp;        // TODO validate in struct.setFieldName
<b class="fc"><i>453</i>&nbsp;        String text = child.getFieldNameSymbol().getText();</b>
<b class="fc"><i>454</i>&nbsp;        IonValueLite concrete = (IonValueLite) child;</b>
<b class="fc"><i>455</i>&nbsp;        _add(text, concrete);</b>
<i>456</i>&nbsp;
<b class="fc"><i>457</i>&nbsp;        return true;</b>
<i>458</i>&nbsp;    }
<i>459</i>&nbsp;
<i>460</i>&nbsp;
<i>461</i>&nbsp;    public ValueFactory add(final String fieldName)
<i>462</i>&nbsp;    {
<b class="fc"><i>463</i>&nbsp;        return new _Private_CurriedValueFactory(_context.getSystem())</b>
<b class="fc"><i>464</i>&nbsp;        {</b>
<i>465</i>&nbsp;            @Override
<i>466</i>&nbsp;            protected void handle(IonValue newValue)
<i>467</i>&nbsp;            {
<b class="fc"><i>468</i>&nbsp;                add(fieldName, newValue);</b>
<b class="fc"><i>469</i>&nbsp;            }</b>
<i>470</i>&nbsp;        };
<i>471</i>&nbsp;    }
<i>472</i>&nbsp;
<i>473</i>&nbsp;
<i>474</i>&nbsp;    /**
<i>475</i>&nbsp;     * Validates the child and checks locks.
<i>476</i>&nbsp;     *
<i>477</i>&nbsp;     * @param fieldName may be null
<i>478</i>&nbsp;     * @param child must be validated and have field name or id set
<i>479</i>&nbsp;     */
<i>480</i>&nbsp;    private void _add(String fieldName, IonValueLite child)
<i>481</i>&nbsp;    {
<b class="fc"><i>482</i>&nbsp;        hasNullFieldName |= fieldName == null;</b>
<b class="fc"><i>483</i>&nbsp;        int size = get_child_count();</b>
<i>484</i>&nbsp;
<i>485</i>&nbsp;        // add this to the Container child collection
<b class="fc"><i>486</i>&nbsp;        add(size, child);</b>
<i>487</i>&nbsp;
<i>488</i>&nbsp;        // if we have a hash map we need to update it now
<b class="fc"><i>489</i>&nbsp;        if (_field_map != null) {</b>
<b class="fc"><i>490</i>&nbsp;            add_field(fieldName, child._elementid());</b>
<i>491</i>&nbsp;        }
<b class="fc"><i>492</i>&nbsp;    }</b>
<i>493</i>&nbsp;
<i>494</i>&nbsp;    public void add(String fieldName, IonValue value)
<i>495</i>&nbsp;    {
<i>496</i>&nbsp;        // Validate everything before altering the child
<b class="fc"><i>497</i>&nbsp;        checkForLock();</b>
<b class="fc"><i>498</i>&nbsp;        validateNewChild(value);</b>
<b class="fc"><i>499</i>&nbsp;        validateFieldName(fieldName);</b>
<i>500</i>&nbsp;
<b class="fc"><i>501</i>&nbsp;        IonValueLite concrete = (IonValueLite) value;</b>
<i>502</i>&nbsp;
<b class="fc"><i>503</i>&nbsp;        _add(fieldName, concrete);</b>
<b class="fc"><i>504</i>&nbsp;        concrete.setFieldName(fieldName);</b>
<b class="fc"><i>505</i>&nbsp;    }</b>
<i>506</i>&nbsp;
<i>507</i>&nbsp;    public void add(SymbolToken fieldName, IonValue child)
<i>508</i>&nbsp;    {
<b class="fc"><i>509</i>&nbsp;        String text = fieldName.getText();</b>
<b class="fc"><i>510</i>&nbsp;        if (text != null)</b>
<i>511</i>&nbsp;        {
<i>512</i>&nbsp;            // Ignoring the sid is safe, but perhaps not the most efficient.
<b class="fc"><i>513</i>&nbsp;            add(text, child);</b>
<b class="fc"><i>514</i>&nbsp;            return;</b>
<i>515</i>&nbsp;        }
<i>516</i>&nbsp;
<b class="fc"><i>517</i>&nbsp;        if (fieldName.getSid() &lt; 0)</b>
<i>518</i>&nbsp;        {
<b class="fc"><i>519</i>&nbsp;            throw new IllegalArgumentException(&quot;fieldName has no text or ID&quot;);</b>
<i>520</i>&nbsp;        }
<i>521</i>&nbsp;
<i>522</i>&nbsp;        // Validate everything before altering the child
<b class="fc"><i>523</i>&nbsp;        checkForLock();</b>
<b class="fc"><i>524</i>&nbsp;        validateNewChild(child);</b>
<i>525</i>&nbsp;
<b class="fc"><i>526</i>&nbsp;        IonValueLite concrete = (IonValueLite) child;</b>
<b class="fc"><i>527</i>&nbsp;        concrete.setFieldNameSymbol(fieldName);</b>
<b class="fc"><i>528</i>&nbsp;        _add(text, concrete);</b>
<b class="fc"><i>529</i>&nbsp;    }</b>
<i>530</i>&nbsp;
<i>531</i>&nbsp;
<i>532</i>&nbsp;    public ValueFactory put(final String fieldName)
<i>533</i>&nbsp;    {
<b class="fc"><i>534</i>&nbsp;        return new _Private_CurriedValueFactory(_context.getSystem())</b>
<b class="fc"><i>535</i>&nbsp;        {</b>
<i>536</i>&nbsp;            @Override
<i>537</i>&nbsp;            protected void handle(IonValue newValue)
<i>538</i>&nbsp;            {
<b class="fc"><i>539</i>&nbsp;                put(fieldName, newValue);</b>
<b class="fc"><i>540</i>&nbsp;            }</b>
<i>541</i>&nbsp;        };
<i>542</i>&nbsp;    }
<i>543</i>&nbsp;
<i>544</i>&nbsp;    public void putAll(Map&lt;? extends String, ? extends IonValue&gt; m)
<i>545</i>&nbsp;    {
<i>546</i>&nbsp;        // TODO this is very inefficient
<b class="fc"><i>547</i>&nbsp;        for (Entry&lt;? extends String, ? extends IonValue&gt; entry : m.entrySet())</b>
<i>548</i>&nbsp;        {
<b class="fc"><i>549</i>&nbsp;            put(entry.getKey(), entry.getValue());</b>
<b class="fc"><i>550</i>&nbsp;        }</b>
<b class="fc"><i>551</i>&nbsp;    }</b>
<i>552</i>&nbsp;
<i>553</i>&nbsp;    /**
<i>554</i>&nbsp;     * put is &quot;make this value the one and only value
<i>555</i>&nbsp;     * associated with this fieldName&quot;.  The side effect
<i>556</i>&nbsp;     * is that if there were multiple fields with this
<i>557</i>&nbsp;     * name when put is complete there will only be the
<i>558</i>&nbsp;     * one value in the collection.
<i>559</i>&nbsp;     */
<i>560</i>&nbsp;    public void put(String fieldName, IonValue value)
<i>561</i>&nbsp;    {
<b class="fc"><i>562</i>&nbsp;        checkForLock();</b>
<i>563</i>&nbsp;
<b class="fc"><i>564</i>&nbsp;        validateFieldName(fieldName);</b>
<b class="fc"><i>565</i>&nbsp;        if (value != null) validateNewChild(value);</b>
<i>566</i>&nbsp;
<b class="fc"><i>567</i>&nbsp;        int lowestRemovedIndex = get_child_count();</b>
<b class="fc"><i>568</i>&nbsp;        boolean any_removed = false;</b>
<i>569</i>&nbsp;
<i>570</i>&nbsp;        // first we remove the any existing fields
<i>571</i>&nbsp;        // associated with fieldName (which may be none)
<b class="fc"><i>572</i>&nbsp;        if (_field_map != null &amp;&amp; _field_map_duplicate_count == 0)</b>
<i>573</i>&nbsp;        {
<i>574</i>&nbsp;            // we have a map and no duplicates so the index
<i>575</i>&nbsp;            // (aka map) is all we need to find the only
<i>576</i>&nbsp;            // value associated with fieldName, if there is one
<b class="fc"><i>577</i>&nbsp;            Integer idx = _field_map.get(fieldName);</b>
<b class="fc"><i>578</i>&nbsp;            if (idx != null) {</b>
<b class="fc"><i>579</i>&nbsp;                lowestRemovedIndex = idx.intValue();</b>
<b class="fc"><i>580</i>&nbsp;                remove_field_from_field_map(fieldName, lowestRemovedIndex);</b>
<b class="fc"><i>581</i>&nbsp;                remove_child(lowestRemovedIndex);</b>
<b class="fc"><i>582</i>&nbsp;                any_removed = true;</b>
<i>583</i>&nbsp;            }
<b class="fc"><i>584</i>&nbsp;        }</b>
<i>585</i>&nbsp;        else {
<i>586</i>&nbsp;            // either we don&#39;t have a map (index) or there
<i>587</i>&nbsp;            // are duplicates in both cases we have to
<i>588</i>&nbsp;            // scan the child list directly.
<i>589</i>&nbsp;            // Walk backwards to minimize array movement
<i>590</i>&nbsp;            // as we remove fields as we encounter them.
<b class="fc"><i>591</i>&nbsp;            int copies_removed = 0;</b>
<b class="fc"><i>592</i>&nbsp;            for (int ii = get_child_count(); ii &gt; 0; )</b>
<i>593</i>&nbsp;            {
<b class="fc"><i>594</i>&nbsp;                ii--;</b>
<b class="fc"><i>595</i>&nbsp;                IonValueLite child = get_child(ii);</b>
<b class="fc"><i>596</i>&nbsp;                if (fieldName.equals(child.getFieldNameSymbol().getText()))</b>
<i>597</i>&nbsp;                {
<i>598</i>&nbsp;                    // done by remove_child: child.detachFromContainer();
<b class="fc"><i>599</i>&nbsp;                    remove_child(ii);</b>
<b class="fc"><i>600</i>&nbsp;                    lowestRemovedIndex = ii;</b>
<b class="fc"><i>601</i>&nbsp;                    copies_removed++;</b>
<b class="fc"><i>602</i>&nbsp;                    any_removed = true;</b>
<i>603</i>&nbsp;                }
<b class="fc"><i>604</i>&nbsp;            }</b>
<b class="fc"><i>605</i>&nbsp;            if (any_removed) {</b>
<b class="fc"><i>606</i>&nbsp;                remove_field(fieldName, lowestRemovedIndex, copies_removed);</b>
<i>607</i>&nbsp;            }
<i>608</i>&nbsp;        }
<b class="fc"><i>609</i>&nbsp;        if (any_removed) {</b>
<b class="fc"><i>610</i>&nbsp;            patch_map_elements_helper(lowestRemovedIndex);</b>
<b class="fc"><i>611</i>&nbsp;            patch_elements_helper(lowestRemovedIndex);</b>
<i>612</i>&nbsp;        }
<i>613</i>&nbsp;
<i>614</i>&nbsp;        // once we&#39;ve removed any existing copy we now add,
<i>615</i>&nbsp;        // this (delete + add == put) turns out be be the
<i>616</i>&nbsp;        // right choice since:
<i>617</i>&nbsp;        //   1 - because of possible duplicates we can&#39;t
<i>618</i>&nbsp;        //       guarantee the idx is stable
<i>619</i>&nbsp;        //   2 - we have to maintain the hash and that
<i>620</i>&nbsp;        //       really means we end up with the delete
<i>621</i>&nbsp;        //       anyway
<i>622</i>&nbsp;        // strictly speaking this approach, while simpler,
<i>623</i>&nbsp;        // is more expensive when we don&#39;t have a has and
<i>624</i>&nbsp;        // the value already exists, and it&#39;s not at the
<i>625</i>&nbsp;        // end of the field list anyway.
<b class="fc"><i>626</i>&nbsp;        if (value != null) {</b>
<b class="fc"><i>627</i>&nbsp;            add(fieldName, value);</b>
<i>628</i>&nbsp;        }
<b class="fc"><i>629</i>&nbsp;    }</b>
<i>630</i>&nbsp;
<i>631</i>&nbsp;    @Override
<i>632</i>&nbsp;    public ListIterator&lt;IonValue&gt; listIterator(int index) {
<b class="fc"><i>633</i>&nbsp;        return new SequenceContentIterator(index, isReadOnly()) {</b>
<i>634</i>&nbsp;            @Override
<i>635</i>&nbsp;            public void remove() {
<b class="fc"><i>636</i>&nbsp;                if (__readOnly) {</b>
<b class="nc"><i>637</i>&nbsp;                    throw new UnsupportedOperationException();</b>
<i>638</i>&nbsp;                }
<b class="fc"><i>639</i>&nbsp;                force_position_sync();</b>
<i>640</i>&nbsp;
<b class="fc"><i>641</i>&nbsp;                int idx = __pos;</b>
<b class="fc"><i>642</i>&nbsp;                if (!__lastMoveWasPrevious) {</b>
<i>643</i>&nbsp;                    // position is 1 ahead of the array index
<b class="fc"><i>644</i>&nbsp;                    idx--;</b>
<i>645</i>&nbsp;                }
<b class="fc"><i>646</i>&nbsp;                if (idx &lt; 0) {</b>
<b class="nc"><i>647</i>&nbsp;                    throw new ArrayIndexOutOfBoundsException();</b>
<i>648</i>&nbsp;                }
<i>649</i>&nbsp;
<b class="fc"><i>650</i>&nbsp;                IonValueLite concrete = __current;</b>
<b class="fc"><i>651</i>&nbsp;                int concrete_idx = concrete._elementid();</b>
<b class="fc"><i>652</i>&nbsp;                assert(concrete_idx == idx);</b>
<i>653</i>&nbsp;
<b class="fc"><i>654</i>&nbsp;                if (_field_map != null) {</b>
<b class="fc"><i>655</i>&nbsp;                    remove_field_from_field_map(concrete.getFieldName(), idx);</b>
<i>656</i>&nbsp;                }
<b class="fc"><i>657</i>&nbsp;                super.remove();</b>
<i>658</i>&nbsp;
<b class="fc"><i>659</i>&nbsp;                if (_field_map != null) {</b>
<b class="fc"><i>660</i>&nbsp;                    patch_map_elements_helper(idx);</b>
<i>661</i>&nbsp;                }
<b class="fc"><i>662</i>&nbsp;            }</b>
<i>663</i>&nbsp;        };
<i>664</i>&nbsp;    }
<i>665</i>&nbsp;
<i>666</i>&nbsp;    public IonValue remove(String fieldName)
<i>667</i>&nbsp;    {
<b class="fc"><i>668</i>&nbsp;        checkForLock();</b>
<i>669</i>&nbsp;
<b class="fc"><i>670</i>&nbsp;        IonValue field = get(fieldName);</b>
<b class="fc"><i>671</i>&nbsp;        if (field == null) {</b>
<b class="fc"><i>672</i>&nbsp;            return null;</b>
<i>673</i>&nbsp;        }
<i>674</i>&nbsp;
<b class="fc"><i>675</i>&nbsp;        int idx = ((IonValueLite)field)._elementid();</b>
<i>676</i>&nbsp;
<i>677</i>&nbsp;        // update the hash map first we don&#39;t want
<i>678</i>&nbsp;        // the child list changed until we&#39;ve done
<i>679</i>&nbsp;        // this since the map update expects the
<i>680</i>&nbsp;        // index value of the remove field to be
<i>681</i>&nbsp;        // correct and unchanged.
<b class="fc"><i>682</i>&nbsp;        if (_field_map != null) {</b>
<b class="fc"><i>683</i>&nbsp;            remove_field_from_field_map(fieldName, idx);</b>
<i>684</i>&nbsp;        }
<i>685</i>&nbsp;
<b class="fc"><i>686</i>&nbsp;        super.remove(field);</b>
<i>687</i>&nbsp;
<b class="fc"><i>688</i>&nbsp;        if (_field_map != null) {</b>
<b class="fc"><i>689</i>&nbsp;            patch_map_elements_helper(idx);</b>
<i>690</i>&nbsp;        }
<i>691</i>&nbsp;
<b class="fc"><i>692</i>&nbsp;        return field;</b>
<i>693</i>&nbsp;    }
<i>694</i>&nbsp;
<i>695</i>&nbsp;    @Override
<i>696</i>&nbsp;    public boolean remove(IonValue element)
<i>697</i>&nbsp;    {
<b class="fc"><i>698</i>&nbsp;        if (element == null) {</b>
<b class="fc"><i>699</i>&nbsp;            throw new NullPointerException();</b>
<i>700</i>&nbsp;        }
<i>701</i>&nbsp;
<b class="fc"><i>702</i>&nbsp;        checkForLock();</b>
<i>703</i>&nbsp;
<b class="fc"><i>704</i>&nbsp;        if (element.getContainer() != this) {</b>
<b class="fc"><i>705</i>&nbsp;            return false;</b>
<i>706</i>&nbsp;        }
<i>707</i>&nbsp;
<b class="fc"><i>708</i>&nbsp;        IonValueLite concrete = (IonValueLite) element;</b>
<b class="fc"><i>709</i>&nbsp;        int idx = concrete._elementid();</b>
<i>710</i>&nbsp;
<i>711</i>&nbsp;        // update the hash map first we don&#39;t want
<i>712</i>&nbsp;        // the child list changed until we&#39;ve done
<i>713</i>&nbsp;        // this since the map update expects the
<i>714</i>&nbsp;        // index value of the remove field to be
<i>715</i>&nbsp;        // correct and unchanged.
<b class="fc"><i>716</i>&nbsp;        if (_field_map != null) {</b>
<b class="fc"><i>717</i>&nbsp;            remove_field_from_field_map(concrete.getFieldName(), idx);</b>
<i>718</i>&nbsp;        }
<i>719</i>&nbsp;
<b class="fc"><i>720</i>&nbsp;        super.remove(concrete);</b>
<i>721</i>&nbsp;
<b class="fc"><i>722</i>&nbsp;        if (_field_map != null) {</b>
<b class="fc"><i>723</i>&nbsp;            patch_map_elements_helper(idx);</b>
<i>724</i>&nbsp;        }
<i>725</i>&nbsp;
<b class="fc"><i>726</i>&nbsp;        return true;</b>
<i>727</i>&nbsp;    }
<i>728</i>&nbsp;
<i>729</i>&nbsp;    public boolean removeAll(String... fieldNames)
<i>730</i>&nbsp;    {
<b class="fc"><i>731</i>&nbsp;        boolean removedAny = false;</b>
<i>732</i>&nbsp;
<b class="fc"><i>733</i>&nbsp;        checkForLock();</b>
<i>734</i>&nbsp;
<b class="fc"><i>735</i>&nbsp;        int size = get_child_count();</b>
<b class="fc"><i>736</i>&nbsp;        for (int ii=size; ii&gt;0; ) {</b>
<b class="fc"><i>737</i>&nbsp;            ii--;</b>
<b class="fc"><i>738</i>&nbsp;            IonValue field = get_child(ii);</b>
<b class="fc"><i>739</i>&nbsp;            if (isListedField(field, fieldNames)) {</b>
<b class="fc"><i>740</i>&nbsp;                field.removeFromContainer();</b>
<b class="fc"><i>741</i>&nbsp;                removedAny = true;</b>
<i>742</i>&nbsp;            }
<b class="fc"><i>743</i>&nbsp;        }</b>
<i>744</i>&nbsp;
<b class="fc"><i>745</i>&nbsp;        return removedAny;</b>
<i>746</i>&nbsp;    }
<i>747</i>&nbsp;
<i>748</i>&nbsp;    public boolean retainAll(String... fieldNames)
<i>749</i>&nbsp;    {
<b class="fc"><i>750</i>&nbsp;        checkForLock();</b>
<i>751</i>&nbsp;
<b class="fc"><i>752</i>&nbsp;        boolean removedAny = false;</b>
<b class="fc"><i>753</i>&nbsp;        int size = get_child_count();</b>
<b class="fc"><i>754</i>&nbsp;        for (int ii=size; ii&gt;0; ) {</b>
<b class="fc"><i>755</i>&nbsp;            ii--;</b>
<b class="fc"><i>756</i>&nbsp;            IonValue field = get_child(ii);</b>
<b class="fc"><i>757</i>&nbsp;            if (! isListedField(field, fieldNames))</b>
<i>758</i>&nbsp;            {
<b class="fc"><i>759</i>&nbsp;                field.removeFromContainer();</b>
<b class="fc"><i>760</i>&nbsp;                removedAny = true;</b>
<i>761</i>&nbsp;            }
<b class="fc"><i>762</i>&nbsp;        }</b>
<b class="fc"><i>763</i>&nbsp;        return removedAny;</b>
<i>764</i>&nbsp;    }
<i>765</i>&nbsp;
<i>766</i>&nbsp;    /**
<i>767</i>&nbsp;     *
<i>768</i>&nbsp;     * @param field must not be null.  It is not required to have a field name.
<i>769</i>&nbsp;     * @param fields must not be null, and must not contain and nulls.
<i>770</i>&nbsp;     * @return true if {@code field.getFieldName()} is in {@code fields}.
<i>771</i>&nbsp;     */
<i>772</i>&nbsp;    private static boolean isListedField(IonValue field, String[] fields)
<i>773</i>&nbsp;    {
<b class="fc"><i>774</i>&nbsp;        String fieldName = field.getFieldName();</b>
<b class="fc"><i>775</i>&nbsp;        for (String key : fields)</b>
<i>776</i>&nbsp;        {
<b class="fc"><i>777</i>&nbsp;            if (key.equals(fieldName)) return true;</b>
<i>778</i>&nbsp;        }
<b class="fc"><i>779</i>&nbsp;        return false;</b>
<i>780</i>&nbsp;    }
<i>781</i>&nbsp;
<i>782</i>&nbsp;
<i>783</i>&nbsp;    /**
<i>784</i>&nbsp;     * Ensures that a given field name is valid. Used as a helper for
<i>785</i>&nbsp;     * methods that have that precondition.
<i>786</i>&nbsp;     *
<i>787</i>&nbsp;     * @throws NullPointerException if the &lt;code&gt;fieldName&lt;/code&gt;
<i>788</i>&nbsp;     * is &lt;code&gt;null&lt;/code&gt;.
<i>789</i>&nbsp;     */
<i>790</i>&nbsp;    private static void validateFieldName(String fieldName)
<i>791</i>&nbsp;    {
<b class="fc"><i>792</i>&nbsp;        if (fieldName == null)</b>
<i>793</i>&nbsp;        {
<b class="fc"><i>794</i>&nbsp;            throw new NullPointerException(&quot;fieldName is null&quot;);</b>
<i>795</i>&nbsp;        }
<b class="fc"><i>796</i>&nbsp;    }</b>
<i>797</i>&nbsp;
<i>798</i>&nbsp;    @Override
<i>799</i>&nbsp;    final void writeBodyTo(IonWriter writer, SymbolTableProvider symbolTableProvider)
<i>800</i>&nbsp;        throws IOException
<i>801</i>&nbsp;    {
<b class="fc"><i>802</i>&nbsp;        if (isNullValue())</b>
<i>803</i>&nbsp;        {
<b class="fc"><i>804</i>&nbsp;            writer.writeNull(IonType.STRUCT);</b>
<i>805</i>&nbsp;        }
<i>806</i>&nbsp;        else
<i>807</i>&nbsp;        {
<b class="fc"><i>808</i>&nbsp;            writer.stepIn(IonType.STRUCT);</b>
<b class="fc"><i>809</i>&nbsp;            writeChildren(writer, this, symbolTableProvider);</b>
<b class="fc"><i>810</i>&nbsp;            writer.stepOut();</b>
<i>811</i>&nbsp;        }
<b class="fc"><i>812</i>&nbsp;    }</b>
<i>813</i>&nbsp;
<i>814</i>&nbsp;    @Override
<i>815</i>&nbsp;    public void accept(ValueVisitor visitor) throws Exception
<i>816</i>&nbsp;    {
<b class="fc"><i>817</i>&nbsp;        visitor.visit(this);</b>
<b class="fc"><i>818</i>&nbsp;    }</b>
<i>819</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2021-02-15 21:53</div>
</div>
</body>
</html>
