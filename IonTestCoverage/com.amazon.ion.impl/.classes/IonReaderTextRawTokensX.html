


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: IonReaderTextRawTokensX</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.amazon.ion.impl</a> ]
</div>

<h1>Coverage Summary for Class: IonReaderTextRawTokensX (com.amazon.ion.impl)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">IonReaderTextRawTokensX</td>
<td class="coverageStat">
  <span class="percent">
    95.6%
  </span>
  <span class="absValue">
    (108/ 113)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.3%
  </span>
  <span class="absValue">
    (975/ 1130)
  </span>
</td>
</tr>
  <tr>
    <td class="name">IonReaderTextRawTokensX$1</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonReaderTextRawTokensX$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonReaderTextRawTokensX$CommentStrategy</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonReaderTextRawTokensX$CommentStrategy$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonReaderTextRawTokensX$CommentStrategy$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonReaderTextRawTokensX$CommentStrategy$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonReaderTextRawTokensX$IonReaderTextTokenException</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonReaderTextRawTokensX$NumericState</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonReaderTextRawTokensX$ProhibitedCharacters</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonReaderTextRawTokensX$ProhibitedCharacters$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonReaderTextRawTokensX$ProhibitedCharacters$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonReaderTextRawTokensX$ProhibitedCharacters$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonReaderTextRawTokensX$Radix</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonReaderTextRawTokensX$Radix$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonReaderTextRawTokensX$Radix$2</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">IonReaderTextRawTokensX$Radix$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    94.8%
  </span>
  <span class="absValue">
    (147/ 155)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.6%
  </span>
  <span class="absValue">
    (1033/ 1193)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
<i>3</i>&nbsp; *
<i>4</i>&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
<i>5</i>&nbsp; * You may not use this file except in compliance with the License.
<i>6</i>&nbsp; * A copy of the License is located at
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
<i>9</i>&nbsp; *
<i>10</i>&nbsp; * or in the &quot;license&quot; file accompanying this file. This file is distributed
<i>11</i>&nbsp; * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
<i>12</i>&nbsp; * express or implied. See the License for the specific language governing
<i>13</i>&nbsp; * permissions and limitations under the License.
<i>14</i>&nbsp; */
<i>15</i>&nbsp;
<i>16</i>&nbsp;package com.amazon.ion.impl;
<i>17</i>&nbsp;
<i>18</i>&nbsp;import static com.amazon.ion.impl.IonTokenConstsX.CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1;
<i>19</i>&nbsp;import static com.amazon.ion.impl.IonTokenConstsX.CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2;
<i>20</i>&nbsp;import static com.amazon.ion.impl.IonTokenConstsX.CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3;
<i>21</i>&nbsp;import static com.amazon.ion.impl.IonTokenConstsX.CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1;
<i>22</i>&nbsp;import static com.amazon.ion.impl.IonTokenConstsX.CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2;
<i>23</i>&nbsp;import static com.amazon.ion.impl.IonTokenConstsX.CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3;
<i>24</i>&nbsp;import static com.amazon.ion.util.IonTextUtils.printCodePointAsString;
<i>25</i>&nbsp;
<i>26</i>&nbsp;import com.amazon.ion.IonException;
<i>27</i>&nbsp;import com.amazon.ion.IonType;
<i>28</i>&nbsp;import com.amazon.ion.UnexpectedEofException;
<i>29</i>&nbsp;import com.amazon.ion.impl.IonTokenConstsX.CharacterSequence;
<i>30</i>&nbsp;import com.amazon.ion.impl.UnifiedSavePointManagerX.SavePoint;
<i>31</i>&nbsp;import com.amazon.ion.util.IonTextUtils;
<i>32</i>&nbsp;import java.io.IOException;
<i>33</i>&nbsp;
<i>34</i>&nbsp;/**
<i>35</i>&nbsp; * Tokenizer for the Ion text parser in IonTextIterator. This
<i>36</i>&nbsp; * reads bytes and returns the interesting tokens it recognizes
<i>37</i>&nbsp; * or an error.  While, currently, this does UTF-8 decoding
<i>38</i>&nbsp; * as it goes that is unnecessary.  The main entry point is
<i>39</i>&nbsp; * lookahead(n) which gets the token type n tokens ahead (0
<i>40</i>&nbsp; * is the next token).  The tokens type, its starting offset
<i>41</i>&nbsp; * in the input stream and its ending offset in the input stream
<i>42</i>&nbsp; * are cached, so lookahead() can be called repeatedly with
<i>43</i>&nbsp; * little overhead.  This supports a 7 token lookahead and requires
<i>44</i>&nbsp; * a &quot;recompile&quot; to change this limit.  (this could be &quot;fixed&quot;
<i>45</i>&nbsp; * but seems unnecessary at this time - the limit is in
<i>46</i>&nbsp; * IonTextTokenizer._token_lookahead_size which is 1 larger than
<i>47</i>&nbsp; * the size of the lookahead allowed)  Tokens are consumed by
<i>48</i>&nbsp; * a call to consumeToken, or the helper consumeTokenAsString.
<i>49</i>&nbsp; * The informational interfaces - getValueStart(), getValueEnd()
<i>50</i>&nbsp; * getValueAsString() can be used to get the contents of the
<i>51</i>&nbsp; * value once the caller has decided how to use it.
<i>52</i>&nbsp; *
<i>53</i>&nbsp; *  This is a copy and paste from IonTextTokenize on the introduction of
<i>54</i>&nbsp; *  the new input abstraction IonInputStream as the source of characters
<i>55</i>&nbsp; *  and bytes for the reader.
<i>56</i>&nbsp; *
<i>57</i>&nbsp; *  This variation does NOT make local copies of the tokens.  It does
<i>58</i>&nbsp; *  start &quot;marking&quot; at the beginning of the token and the end.  The stream
<i>59</i>&nbsp; *  will buffer the input until the mark is released.
<i>60</i>&nbsp; *
<i>61</i>&nbsp; *  The result is that only the most recent token is available to the
<i>62</i>&nbsp; *  calling reader.
<i>63</i>&nbsp; *
<i>64</i>&nbsp; */
<b class="fc"><i>65</i>&nbsp;final class IonReaderTextRawTokensX</b>
<i>66</i>&nbsp;{
<i>67</i>&nbsp;    static final boolean _debug = false;
<i>68</i>&nbsp;
<b class="fc"><i>69</i>&nbsp;    private static final Appendable NULL_APPENDABLE = new Appendable()</b>
<b class="fc"><i>70</i>&nbsp;    {</b>
<i>71</i>&nbsp;        public Appendable append(CharSequence csq) throws IOException
<i>72</i>&nbsp;        {
<b class="nc"><i>73</i>&nbsp;            return this;</b>
<i>74</i>&nbsp;        }
<i>75</i>&nbsp;
<i>76</i>&nbsp;        public Appendable append(CharSequence csq, int start, int end)
<i>77</i>&nbsp;            throws IOException
<i>78</i>&nbsp;        {
<b class="nc"><i>79</i>&nbsp;            return this;</b>
<i>80</i>&nbsp;        }
<i>81</i>&nbsp;
<i>82</i>&nbsp;        public Appendable append(char c) throws IOException
<i>83</i>&nbsp;        {
<b class="fc"><i>84</i>&nbsp;            return this;</b>
<i>85</i>&nbsp;        }
<i>86</i>&nbsp;    };
<i>87</i>&nbsp;
<i>88</i>&nbsp;    static final int   BASE64_EOF = 128; // still a byte, not -1, none of the low 6 bits on
<b class="fc"><i>89</i>&nbsp;    static final int[] BASE64_CHAR_TO_BIN = Base64Encoder.Base64EncodingCharToInt;</b>
<b class="fc"><i>90</i>&nbsp;    static final int   BASE64_TERMINATOR_CHAR = Base64Encoder.Base64EncodingTerminator;</b>
<i>91</i>&nbsp;
<b class="fc"><i>92</i>&nbsp;    private UnifiedInputStreamX  _stream = null;</b>
<b class="fc"><i>93</i>&nbsp;    private int                 _token = -1;</b>
<i>94</i>&nbsp;    /** are we at the beginning of this token (false == done with it) */
<i>95</i>&nbsp;    private boolean             _unfinished_token;
<i>96</i>&nbsp;    private long                _line_count;
<i>97</i>&nbsp;    private long                _line_starting_position;
<b class="fc"><i>98</i>&nbsp;    private boolean             _line_count_has_cached = false;</b>
<i>99</i>&nbsp;    private long                _line_count_cached;
<i>100</i>&nbsp;    private long                _line_offset_cached;
<i>101</i>&nbsp;
<i>102</i>&nbsp;    /** number of base64 decoded bytes in the stack, used to decode base64 */
<i>103</i>&nbsp;    private int                 _base64_prefetch_count;
<i>104</i>&nbsp;    /**
<i>105</i>&nbsp;     * since this &quot;stack&quot; will only 0-2 bytes deep, we&#39;ll just shift them
<i>106</i>&nbsp;     * into an int
<i>107</i>&nbsp;     */
<i>108</i>&nbsp;    private int                 _base64_prefetch_stack;
<i>109</i>&nbsp;
<i>110</i>&nbsp;
<i>111</i>&nbsp;    /**
<i>112</i>&nbsp;     * IonTokenReader constructor requires a UnifiedInputStream
<i>113</i>&nbsp;     * as the source of bytes/chars that serve as the basic input
<i>114</i>&nbsp;     *
<i>115</i>&nbsp;     * @param iis wrapped input stream
<i>116</i>&nbsp;     */
<i>117</i>&nbsp;    public IonReaderTextRawTokensX(UnifiedInputStreamX iis) {
<b class="nc"><i>118</i>&nbsp;        this(iis, 1, 1);</b>
<b class="nc"><i>119</i>&nbsp;    }</b>
<i>120</i>&nbsp;
<i>121</i>&nbsp;    public IonReaderTextRawTokensX(UnifiedInputStreamX iis, long starting_line,
<i>122</i>&nbsp;                                   long starting_column)
<b class="fc"><i>123</i>&nbsp;    {</b>
<b class="fc"><i>124</i>&nbsp;        _stream = iis;</b>
<b class="fc"><i>125</i>&nbsp;        _line_count = starting_line;</b>
<b class="fc"><i>126</i>&nbsp;        _line_starting_position = _stream.getPosition() - starting_column;</b>
<b class="fc"><i>127</i>&nbsp;    }</b>
<i>128</i>&nbsp;
<i>129</i>&nbsp;    public void close()
<i>130</i>&nbsp;        throws IOException
<i>131</i>&nbsp;    {
<b class="fc"><i>132</i>&nbsp;        _stream.close();</b>
<b class="fc"><i>133</i>&nbsp;    }</b>
<i>134</i>&nbsp;
<b class="fc"><i>135</i>&nbsp;    public int  getToken()      { return _token; }</b>
<b class="fc"><i>136</i>&nbsp;    public long getLineNumber() { return _line_count; }</b>
<i>137</i>&nbsp;    public long getLineOffset() {
<b class="fc"><i>138</i>&nbsp;        long stream_position = _stream.getPosition();</b>
<b class="fc"><i>139</i>&nbsp;        long offset = stream_position - _line_starting_position;</b>
<b class="fc"><i>140</i>&nbsp;        return offset;</b>
<i>141</i>&nbsp;    }
<i>142</i>&nbsp;
<b class="fc"><i>143</i>&nbsp;    UnifiedInputStreamX getSourceStream() { return this._stream; }</b>
<i>144</i>&nbsp;
<i>145</i>&nbsp;    public final boolean isBufferedInput()
<i>146</i>&nbsp;    {
<b class="fc"><i>147</i>&nbsp;        boolean is_buffered = ! _stream._is_stream;</b>
<b class="fc"><i>148</i>&nbsp;        return is_buffered;</b>
<i>149</i>&nbsp;    }
<i>150</i>&nbsp;
<i>151</i>&nbsp;    protected String input_position() {
<b class="fc"><i>152</i>&nbsp;        String s = &quot; at line &quot;</b>
<b class="fc"><i>153</i>&nbsp;                + getLineNumber()</b>
<i>154</i>&nbsp;                + &quot; offset &quot;
<b class="fc"><i>155</i>&nbsp;                + getLineOffset();</b>
<b class="fc"><i>156</i>&nbsp;        return s;</b>
<i>157</i>&nbsp;    }
<b class="fc"><i>158</i>&nbsp;    public final boolean isUnfinishedToken() { return  _unfinished_token; }</b>
<i>159</i>&nbsp;
<i>160</i>&nbsp;    public final void tokenIsFinished() {
<b class="fc"><i>161</i>&nbsp;        _unfinished_token = false;</b>
<b class="fc"><i>162</i>&nbsp;        _base64_prefetch_count = 0;</b>
<b class="fc"><i>163</i>&nbsp;    }</b>
<i>164</i>&nbsp;
<i>165</i>&nbsp;    //
<i>166</i>&nbsp;    //  character routines to fetch characters and
<i>167</i>&nbsp;    //  handle look ahead and line counting and such
<i>168</i>&nbsp;    //
<i>169</i>&nbsp;    protected final int read_char() throws IOException
<i>170</i>&nbsp;    {
<b class="fc"><i>171</i>&nbsp;        int c = _stream.read();</b>
<b class="fc"><i>172</i>&nbsp;        if (c == &#39;\r&#39; || c == &#39;\n&#39;) {</b>
<b class="fc"><i>173</i>&nbsp;            c = line_count(c);</b>
<i>174</i>&nbsp;        }
<b class="fc"><i>175</i>&nbsp;        return c;</b>
<i>176</i>&nbsp;    }
<i>177</i>&nbsp;
<i>178</i>&nbsp;    /**
<i>179</i>&nbsp;     * NOT for use outside of string/symbol/clob!
<i>180</i>&nbsp;     * Absorbs backslash-NL pairs, returning
<i>181</i>&nbsp;     * {@link #CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1} etc.
<i>182</i>&nbsp;     */
<i>183</i>&nbsp;    protected final int read_string_char(ProhibitedCharacters prohibitedCharacters) throws IOException
<i>184</i>&nbsp;    {
<b class="fc"><i>185</i>&nbsp;        int c = _stream.read();</b>
<b class="fc"><i>186</i>&nbsp;        if (prohibitedCharacters.includes(c)) {</b>
<b class="fc"><i>187</i>&nbsp;            error(&quot;invalid character [&quot; + printCodePointAsString(c) + &quot;]&quot;);</b>
<i>188</i>&nbsp;        }
<i>189</i>&nbsp;        // the c == &#39;\\&#39; clause will cause us to eat ALL slash-newlines
<b class="fc"><i>190</i>&nbsp;        if (c == &#39;\r&#39; || c == &#39;\n&#39; || c == &#39;\\&#39;) {</b>
<b class="fc"><i>191</i>&nbsp;            c = line_count(c);</b>
<i>192</i>&nbsp;        }
<b class="fc"><i>193</i>&nbsp;        return c;</b>
<i>194</i>&nbsp;    }
<i>195</i>&nbsp;
<i>196</i>&nbsp;    private final void unread_char(int c)
<i>197</i>&nbsp;    {
<b class="fc"><i>198</i>&nbsp;        if (c &lt; 0) {</b>
<b class="fc"><i>199</i>&nbsp;            switch (c) {</b>
<i>200</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
<b class="fc"><i>201</i>&nbsp;                line_count_unread(c);</b>
<b class="fc"><i>202</i>&nbsp;                _stream.unread(&#39;\n&#39;);</b>
<b class="fc"><i>203</i>&nbsp;                break;</b>
<i>204</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
<b class="fc"><i>205</i>&nbsp;                line_count_unread(c);</b>
<b class="fc"><i>206</i>&nbsp;                _stream.unread(&#39;\r&#39;);</b>
<b class="fc"><i>207</i>&nbsp;                break;</b>
<i>208</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
<b class="fc"><i>209</i>&nbsp;                line_count_unread(c);</b>
<b class="fc"><i>210</i>&nbsp;                _stream.unread(&#39;\n&#39;);</b>
<b class="fc"><i>211</i>&nbsp;                _stream.unread(&#39;\r&#39;);</b>
<b class="fc"><i>212</i>&nbsp;                break;</b>
<i>213</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
<b class="nc"><i>214</i>&nbsp;                _stream.unread(&#39;\n&#39;);</b>
<b class="nc"><i>215</i>&nbsp;                _stream.unread(&#39;\\&#39;);</b>
<b class="nc"><i>216</i>&nbsp;                break;</b>
<i>217</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
<b class="nc"><i>218</i>&nbsp;                _stream.unread(&#39;\r&#39;);</b>
<b class="nc"><i>219</i>&nbsp;                _stream.unread(&#39;\\&#39;);</b>
<b class="nc"><i>220</i>&nbsp;                break;</b>
<i>221</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
<b class="nc"><i>222</i>&nbsp;                _stream.unread(&#39;\n&#39;);</b>
<b class="nc"><i>223</i>&nbsp;                _stream.unread(&#39;\r&#39;);</b>
<b class="nc"><i>224</i>&nbsp;                _stream.unread(&#39;\\&#39;);</b>
<b class="nc"><i>225</i>&nbsp;                break;</b>
<i>226</i>&nbsp;            case UnifiedInputStreamX.EOF:
<b class="fc"><i>227</i>&nbsp;                _stream.unread(UnifiedInputStreamX.EOF);</b>
<b class="fc"><i>228</i>&nbsp;                break;</b>
<i>229</i>&nbsp;            default:
<b class="nc"><i>230</i>&nbsp;                assert false</b>
<i>231</i>&nbsp;                    : &quot;INVALID SPECIAL CHARACTER ENCOUNTERED: &quot; + c;
<i>232</i>&nbsp;            }
<i>233</i>&nbsp;        }
<i>234</i>&nbsp;        else  {
<b class="fc"><i>235</i>&nbsp;            _stream.unread(c);</b>
<i>236</i>&nbsp;        }
<b class="fc"><i>237</i>&nbsp;    }</b>
<i>238</i>&nbsp;
<i>239</i>&nbsp;    private final int line_count_unread(int c) {
<b class="fc"><i>240</i>&nbsp;        assert( c == CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1</b>
<i>241</i>&nbsp;             || c == CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2
<i>242</i>&nbsp;             || c == CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3
<i>243</i>&nbsp;             || c == CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1
<i>244</i>&nbsp;             || c == CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2
<i>245</i>&nbsp;             || c == CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3
<i>246</i>&nbsp;        );
<b class="fc"><i>247</i>&nbsp;        if (_line_count_has_cached) {</b>
<b class="fc"><i>248</i>&nbsp;            _line_count = _line_count_cached;</b>
<b class="fc"><i>249</i>&nbsp;            _line_starting_position = _line_offset_cached;</b>
<b class="fc"><i>250</i>&nbsp;            _line_count_has_cached = false;</b>
<i>251</i>&nbsp;        }
<b class="fc"><i>252</i>&nbsp;        return c;</b>
<i>253</i>&nbsp;    }
<i>254</i>&nbsp;    private final int line_count(int c) throws IOException
<i>255</i>&nbsp;    {
<i>256</i>&nbsp;        // check for the slash new line case (and we&#39;l
<i>257</i>&nbsp;        // consume both here it that&#39;s what we find
<b class="fc"><i>258</i>&nbsp;        switch (c) {</b>
<i>259</i>&nbsp;        case &#39;\\&#39;:
<i>260</i>&nbsp;            {
<b class="fc"><i>261</i>&nbsp;                int c2 = _stream.read();</b>
<b class="fc"><i>262</i>&nbsp;                switch (c2) {</b>
<i>263</i>&nbsp;                case &#39;\r&#39;:  // DOS &lt;cr&gt;&lt;lf&gt;  or old Mac &lt;cr&gt;
<b class="fc"><i>264</i>&nbsp;                    int c3 = _stream.read();</b>
<b class="fc"><i>265</i>&nbsp;                    if (c3 != &#39;\n&#39;) {</b>
<b class="fc"><i>266</i>&nbsp;                        unread_char(c3);</b>
<b class="fc"><i>267</i>&nbsp;                        c = CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2;</b>
<i>268</i>&nbsp;                    }
<i>269</i>&nbsp;                    else {
<b class="fc"><i>270</i>&nbsp;                        c = CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3;</b>
<i>271</i>&nbsp;                    }
<b class="fc"><i>272</i>&nbsp;                    break;</b>
<i>273</i>&nbsp;                case &#39;\n&#39;:
<i>274</i>&nbsp;                    // Unix and new Mac (also Unix) &lt;lf&gt;
<b class="fc"><i>275</i>&nbsp;                    c = CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1;</b>
<b class="fc"><i>276</i>&nbsp;                    break;</b>
<i>277</i>&nbsp;                default:
<i>278</i>&nbsp;                    // not a slash new line, so we&#39;ll just return the slash
<i>279</i>&nbsp;                    // leave it to be handled elsewhere
<b class="fc"><i>280</i>&nbsp;                    unread_char(c2);</b>
<b class="fc"><i>281</i>&nbsp;                    return c;</b>
<i>282</i>&nbsp;                }
<i>283</i>&nbsp;            }
<b class="fc"><i>284</i>&nbsp;            break;</b>
<i>285</i>&nbsp;        case &#39;\r&#39;:
<i>286</i>&nbsp;            {
<i>287</i>&nbsp;                // convert &#39;\r&#39; or &#39;\r\n&#39; into the appropriate CHAR_SEQ
<i>288</i>&nbsp;                // pseudo character
<b class="fc"><i>289</i>&nbsp;                int c2 = _stream.read();</b>
<b class="fc"><i>290</i>&nbsp;                if (c2 == &#39;\n&#39;) {</b>
<b class="fc"><i>291</i>&nbsp;                    c = CHAR_SEQ_NEWLINE_SEQUENCE_3;</b>
<i>292</i>&nbsp;                }
<i>293</i>&nbsp;                else {
<b class="fc"><i>294</i>&nbsp;                    unread_char(c2);</b>
<b class="fc"><i>295</i>&nbsp;                    c = CHAR_SEQ_NEWLINE_SEQUENCE_2;</b>
<i>296</i>&nbsp;                }
<i>297</i>&nbsp;            }
<b class="fc"><i>298</i>&nbsp;            break;</b>
<i>299</i>&nbsp;        case &#39;\n&#39;:
<b class="fc"><i>300</i>&nbsp;            c = CHAR_SEQ_NEWLINE_SEQUENCE_1;</b>
<b class="fc"><i>301</i>&nbsp;            break;</b>
<i>302</i>&nbsp;        default:
<b class="nc"><i>303</i>&nbsp;            throw new IllegalStateException();</b>
<i>304</i>&nbsp;        }
<i>305</i>&nbsp;
<i>306</i>&nbsp;        // before we adjust the line count we save it so that
<i>307</i>&nbsp;        // we can recover from a unread of a line terminator
<i>308</i>&nbsp;        // note that we can only recover from a single line
<i>309</i>&nbsp;        // terminator unread, but that should be enough.  We
<i>310</i>&nbsp;        // only unread whitespace if it&#39;s a delimiter, and
<i>311</i>&nbsp;        // then we only have to unread a single instance.
<b class="fc"><i>312</i>&nbsp;        _line_count_cached = _line_count;</b>
<b class="fc"><i>313</i>&nbsp;        _line_offset_cached = _line_starting_position;</b>
<b class="fc"><i>314</i>&nbsp;        _line_count_has_cached = true;</b>
<i>315</i>&nbsp;
<i>316</i>&nbsp;        // anything else (and that should only be either a new line
<i>317</i>&nbsp;        // of IonTokenConsts.ESCAPED_NEWLINE_SEQUENCE passed in) we will
<i>318</i>&nbsp;        // return the char unchanged and line count
<b class="fc"><i>319</i>&nbsp;        _line_count++;</b>
<i>320</i>&nbsp;        // since we want the first character of the line to be 1, not 0:
<b class="fc"><i>321</i>&nbsp;        _line_starting_position = _stream.getPosition() - 1;</b>
<i>322</i>&nbsp;
<b class="fc"><i>323</i>&nbsp;        return c;</b>
<i>324</i>&nbsp;    }
<i>325</i>&nbsp;
<i>326</i>&nbsp;    /**
<i>327</i>&nbsp;     * peeks into the input stream to see if the next token
<i>328</i>&nbsp;     * would be a double colon.  If indeed this is the case
<i>329</i>&nbsp;     * it skips the two colons and returns true.  If not
<i>330</i>&nbsp;     * it unreads the 1 or 2 real characters it read and
<i>331</i>&nbsp;     * return false.
<i>332</i>&nbsp;     * It always consumes any preceding whitespace.
<i>333</i>&nbsp;     * @return true if the next token is a double colon, false otherwise
<i>334</i>&nbsp;     * @throws IOException
<i>335</i>&nbsp;     */
<i>336</i>&nbsp;    public final boolean skipDoubleColon() throws IOException
<i>337</i>&nbsp;    {
<b class="fc"><i>338</i>&nbsp;        int c = skip_over_whitespace();</b>
<b class="fc"><i>339</i>&nbsp;        if (c != &#39;:&#39;) {</b>
<b class="fc"><i>340</i>&nbsp;            unread_char(c);</b>
<b class="fc"><i>341</i>&nbsp;            return false;</b>
<i>342</i>&nbsp;        }
<b class="fc"><i>343</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>344</i>&nbsp;        if (c != &#39;:&#39;) {</b>
<b class="fc"><i>345</i>&nbsp;            unread_char(c);</b>
<b class="fc"><i>346</i>&nbsp;            unread_char(&#39;:&#39;);</b>
<b class="fc"><i>347</i>&nbsp;            return false;</b>
<i>348</i>&nbsp;        }
<b class="fc"><i>349</i>&nbsp;        return true;</b>
<i>350</i>&nbsp;    }
<i>351</i>&nbsp;
<i>352</i>&nbsp;
<i>353</i>&nbsp;    /**
<i>354</i>&nbsp;     * peeks into the input stream to see if we have an
<i>355</i>&nbsp;     * unquoted symbol that resolves to one of the ion
<i>356</i>&nbsp;     * types.  If it does it consumes the input and
<i>357</i>&nbsp;     * returns the type keyword id.  If not is unreads
<i>358</i>&nbsp;     * the non-whitespace characters and the dot, which
<i>359</i>&nbsp;     * the input argument &#39;c&#39; should be.
<i>360</i>&nbsp;     */
<i>361</i>&nbsp;    public final int peekNullTypeSymbol() throws IOException
<i>362</i>&nbsp;    {
<i>363</i>&nbsp;        // the &#39;.&#39; has to follow the &#39;null&#39; immediately
<b class="fc"><i>364</i>&nbsp;        int c = read_char();</b>
<b class="fc"><i>365</i>&nbsp;        if (c != &#39;.&#39;) {</b>
<b class="fc"><i>366</i>&nbsp;            unread_char(c);</b>
<b class="fc"><i>367</i>&nbsp;            return IonTokenConstsX.KEYWORD_none;</b>
<i>368</i>&nbsp;        }
<i>369</i>&nbsp;
<i>370</i>&nbsp;        // we have a dot, start reading through the following non-whitespace
<i>371</i>&nbsp;        // and we&#39;ll collect it so that we can unread it in the event
<i>372</i>&nbsp;        // we don&#39;t actually see a type name
<b class="fc"><i>373</i>&nbsp;        int[] read_ahead = new int[IonTokenConstsX.TN_MAX_NAME_LENGTH + 1];</b>
<b class="fc"><i>374</i>&nbsp;        int read_count = 0;</b>
<b class="fc"><i>375</i>&nbsp;        int possible_names = IonTokenConstsX.KW_ALL_BITS;</b>
<i>376</i>&nbsp;
<b class="fc"><i>377</i>&nbsp;        while (read_count &lt; IonTokenConstsX.TN_MAX_NAME_LENGTH + 1) {</b>
<b class="fc"><i>378</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>379</i>&nbsp;            read_ahead[read_count++] = c;</b>
<b class="fc"><i>380</i>&nbsp;            int letter_idx = IonTokenConstsX.typeNameLetterIdx(c);</b>
<b class="fc"><i>381</i>&nbsp;            if (letter_idx &lt; 1) {</b>
<b class="fc"><i>382</i>&nbsp;                if (IonTokenConstsX.isValidTerminatingCharForInf(c)) {</b>
<i>383</i>&nbsp;                    // it&#39;s not a letter we care about but it is
<i>384</i>&nbsp;                    // a valid end of const, so maybe we have a keyword now
<i>385</i>&nbsp;                    // we always exit the loop here since we look
<i>386</i>&nbsp;                    // too far so any letter is invalid at pos 10
<b class="fc"><i>387</i>&nbsp;                    break;</b>
<i>388</i>&nbsp;                }
<b class="nc"><i>389</i>&nbsp;                return peekNullTypeSymbolUndo(read_ahead, read_count);</b>
<i>390</i>&nbsp;            }
<b class="fc"><i>391</i>&nbsp;            int mask = IonTokenConstsX.typeNamePossibilityMask(read_count - 1, letter_idx);</b>
<b class="fc"><i>392</i>&nbsp;            possible_names &amp;= mask;</b>
<b class="fc"><i>393</i>&nbsp;            if (possible_names == 0) {</b>
<i>394</i>&nbsp;                // in this case it can&#39;t be a valid keyword since
<i>395</i>&nbsp;                // it has identifier chars (letters) at 1 past the
<i>396</i>&nbsp;                // last possible end (at least)
<b class="fc"><i>397</i>&nbsp;                return peekNullTypeSymbolUndo(read_ahead, read_count);</b>
<i>398</i>&nbsp;            }
<b class="fc"><i>399</i>&nbsp;        }</b>
<i>400</i>&nbsp;        // now lets get the keyword value from our bit mask
<i>401</i>&nbsp;        // at this point we can fail since we may have hit
<i>402</i>&nbsp;        // a valid terminator before we&#39;re done with all key
<i>403</i>&nbsp;        // words.  We even have to check the length.
<i>404</i>&nbsp;        // for example &quot;in)&quot; matches both letters to the
<i>405</i>&nbsp;        // typename int and terminates validly - but isn&#39;t
<i>406</i>&nbsp;        // long enough, but with length we have enough to be sure
<i>407</i>&nbsp;        // with the actual type names we&#39;re using in 1.0
<b class="fc"><i>408</i>&nbsp;        int kw = IonTokenConstsX.typeNameKeyWordFromMask(possible_names, read_count-1);</b>
<b class="fc"><i>409</i>&nbsp;        if (kw == IonTokenConstsX.KEYWORD_unrecognized) {</b>
<b class="fc"><i>410</i>&nbsp;            peekNullTypeSymbolUndo(read_ahead, read_count);</b>
<i>411</i>&nbsp;        }
<i>412</i>&nbsp;        else {
<i>413</i>&nbsp;            // since we&#39;re accepting the rest we aren&#39;t unreading anything
<i>414</i>&nbsp;            // else - but we still have to unread the character that stopped us
<b class="fc"><i>415</i>&nbsp;            unread_char(c);</b>
<i>416</i>&nbsp;        }
<b class="fc"><i>417</i>&nbsp;        return kw;</b>
<i>418</i>&nbsp;    }
<i>419</i>&nbsp;    private final int peekNullTypeSymbolUndo(int[] read_ahead, int read_count)
<i>420</i>&nbsp;    {
<b class="fc"><i>421</i>&nbsp;        String type_error = &quot;&quot;;</b>
<b class="fc"><i>422</i>&nbsp;        for (int ii=0; ii&lt;read_count; ii++) {</b>
<i>423</i>&nbsp;            // this (string concatenation) is horrible, but we&#39;re about throw anyway
<b class="fc"><i>424</i>&nbsp;            type_error += (char)read_ahead[ii];</b>
<i>425</i>&nbsp;        }
<i>426</i>&nbsp;
<b class="fc"><i>427</i>&nbsp;        String message = &quot;invalid type name on a typed null value&quot;;</b>
<b class="fc"><i>428</i>&nbsp;        error(message); // this throws so we won&#39;t actually return</b>
<b class="nc"><i>429</i>&nbsp;        return IonTokenConstsX.KEYWORD_unrecognized;</b>
<i>430</i>&nbsp;    }
<i>431</i>&nbsp;
<i>432</i>&nbsp;    /**
<i>433</i>&nbsp;     * peeks into the input stream to see what non-whitespace
<i>434</i>&nbsp;     * character is coming up.  If it is a double quote or
<i>435</i>&nbsp;     * a triple quote this returns true as either distinguished
<i>436</i>&nbsp;     * the contents of a lob as distinctly a clob.  Otherwise
<i>437</i>&nbsp;     * it returns false.
<i>438</i>&nbsp;     * In either case it unreads whatever non-whitespace it read
<i>439</i>&nbsp;     * to decide.
<i>440</i>&nbsp;     * @return true if the next token is a double or triple quote, false otherwise
<i>441</i>&nbsp;     * @throws IOException
<i>442</i>&nbsp;     */
<i>443</i>&nbsp;    public final int peekLobStartPunctuation() throws IOException
<i>444</i>&nbsp;    {
<b class="fc"><i>445</i>&nbsp;        int c = skip_over_lob_whitespace();</b>
<b class="fc"><i>446</i>&nbsp;        if (c == &#39;&quot;&#39;) {</b>
<i>447</i>&nbsp;            //unread_char(c);
<b class="fc"><i>448</i>&nbsp;            return IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE;</b>
<i>449</i>&nbsp;        }
<b class="fc"><i>450</i>&nbsp;        if (c != &#39;\&#39;&#39;) {</b>
<b class="fc"><i>451</i>&nbsp;            unread_char(c);</b>
<b class="fc"><i>452</i>&nbsp;            return IonTokenConstsX.TOKEN_ERROR;</b>
<i>453</i>&nbsp;        }
<b class="fc"><i>454</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>455</i>&nbsp;        if (c != &#39;\&#39;&#39;) {</b>
<b class="fc"><i>456</i>&nbsp;            unread_char(c);</b>
<b class="fc"><i>457</i>&nbsp;            unread_char(&#39;\&#39;&#39;);</b>
<b class="fc"><i>458</i>&nbsp;            return IonTokenConstsX.TOKEN_ERROR;</b>
<i>459</i>&nbsp;        }
<b class="fc"><i>460</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>461</i>&nbsp;        if (c != &#39;\&#39;&#39;) {</b>
<b class="nc"><i>462</i>&nbsp;            unread_char(c);</b>
<b class="nc"><i>463</i>&nbsp;            unread_char(&#39;\&#39;&#39;);</b>
<b class="nc"><i>464</i>&nbsp;            unread_char(&#39;\&#39;&#39;);</b>
<b class="nc"><i>465</i>&nbsp;            return IonTokenConstsX.TOKEN_ERROR;</b>
<i>466</i>&nbsp;        }
<b class="fc"><i>467</i>&nbsp;        return IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE;</b>
<i>468</i>&nbsp;    }
<i>469</i>&nbsp;
<i>470</i>&nbsp;    /** Expects optional whitespace then }} */
<i>471</i>&nbsp;    protected final void skip_clob_close_punctuation() throws IOException {
<b class="fc"><i>472</i>&nbsp;        int c = skip_over_clob_whitespace();</b>
<b class="fc"><i>473</i>&nbsp;        if (c == &#39;}&#39;) {</b>
<b class="fc"><i>474</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>475</i>&nbsp;            if (c == &#39;}&#39;) {</b>
<b class="fc"><i>476</i>&nbsp;                return;</b>
<i>477</i>&nbsp;            }
<b class="nc"><i>478</i>&nbsp;            unread_char(c);</b>
<b class="nc"><i>479</i>&nbsp;            c = &#39;}&#39;;</b>
<i>480</i>&nbsp;        }
<b class="fc"><i>481</i>&nbsp;        unread_char(c);</b>
<b class="fc"><i>482</i>&nbsp;        error(&quot;invalid closing puctuation for CLOB&quot;);</b>
<b class="nc"><i>483</i>&nbsp;    }</b>
<i>484</i>&nbsp;
<i>485</i>&nbsp;
<i>486</i>&nbsp;    protected final void finish_token(SavePoint sp) throws IOException
<i>487</i>&nbsp;    {
<b class="fc"><i>488</i>&nbsp;        if (_unfinished_token) {</b>
<b class="fc"><i>489</i>&nbsp;            int c = skip_to_end(sp);</b>
<b class="fc"><i>490</i>&nbsp;            unread_char(c);</b>
<b class="fc"><i>491</i>&nbsp;            _unfinished_token = false;</b>
<i>492</i>&nbsp;        }
<b class="fc"><i>493</i>&nbsp;    }</b>
<i>494</i>&nbsp;
<i>495</i>&nbsp;    private final int skip_to_end(SavePoint sp)  throws IOException
<i>496</i>&nbsp;    {
<i>497</i>&nbsp;        int c;
<i>498</i>&nbsp;
<i>499</i>&nbsp;        // FIXME lots of inconsistency here!
<i>500</i>&nbsp;        // Sometimes the token&#39;s first character is still on the stream,
<i>501</i>&nbsp;        // sometimes it&#39;s already been consumed.
<i>502</i>&nbsp;
<b class="fc"><i>503</i>&nbsp;        switch (_token) {</b>
<i>504</i>&nbsp;        case IonTokenConstsX.TOKEN_UNKNOWN_NUMERIC:
<b class="nc"><i>505</i>&nbsp;            c = skip_over_number(sp);</b>
<b class="nc"><i>506</i>&nbsp;            break;</b>
<i>507</i>&nbsp;        case IonTokenConstsX.TOKEN_INT:
<b class="fc"><i>508</i>&nbsp;            c = skip_over_int(sp);</b>
<b class="fc"><i>509</i>&nbsp;            break;</b>
<i>510</i>&nbsp;        case IonTokenConstsX.TOKEN_HEX:
<b class="fc"><i>511</i>&nbsp;            c = skipOverRadix(sp, Radix.HEX);</b>
<b class="fc"><i>512</i>&nbsp;            break;</b>
<i>513</i>&nbsp;        case IonTokenConstsX.TOKEN_BINARY:
<b class="fc"><i>514</i>&nbsp;            c = skipOverRadix(sp, Radix.BINARY);</b>
<b class="fc"><i>515</i>&nbsp;            break;</b>
<i>516</i>&nbsp;        case IonTokenConstsX.TOKEN_DECIMAL:
<b class="fc"><i>517</i>&nbsp;            c = skip_over_decimal(sp);</b>
<b class="fc"><i>518</i>&nbsp;            break;</b>
<i>519</i>&nbsp;        case IonTokenConstsX.TOKEN_FLOAT:
<b class="fc"><i>520</i>&nbsp;            c = skip_over_float(sp);</b>
<b class="fc"><i>521</i>&nbsp;            break;</b>
<i>522</i>&nbsp;        case IonTokenConstsX.TOKEN_TIMESTAMP:
<b class="fc"><i>523</i>&nbsp;            c = skip_over_timestamp(sp);</b>
<b class="fc"><i>524</i>&nbsp;            break;</b>
<i>525</i>&nbsp;        case IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER:
<b class="fc"><i>526</i>&nbsp;            c = skip_over_symbol_identifier(sp);</b>
<b class="fc"><i>527</i>&nbsp;            break;</b>
<i>528</i>&nbsp;        case IonTokenConstsX.TOKEN_SYMBOL_QUOTED:
<i>529</i>&nbsp;            // Initial single-quote has been consumed!
<b class="fc"><i>530</i>&nbsp;            assert(!is_2_single_quotes_helper());</b>
<b class="fc"><i>531</i>&nbsp;            c = skip_single_quoted_string(sp);</b>
<b class="fc"><i>532</i>&nbsp;            break;</b>
<i>533</i>&nbsp;        case IonTokenConstsX.TOKEN_SYMBOL_OPERATOR:
<i>534</i>&nbsp;            // Initial operator char has NOT been consumed
<b class="fc"><i>535</i>&nbsp;            c = skip_over_symbol_operator(sp);</b>
<b class="fc"><i>536</i>&nbsp;            break;</b>
<i>537</i>&nbsp;        case IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE:
<b class="fc"><i>538</i>&nbsp;            skip_double_quoted_string_helper(); // FIXME Why no sp here?</b>
<b class="fc"><i>539</i>&nbsp;            c = skip_over_whitespace();</b>
<b class="fc"><i>540</i>&nbsp;            break;</b>
<i>541</i>&nbsp;        case IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE:
<b class="fc"><i>542</i>&nbsp;            skip_triple_quoted_string(sp);</b>
<b class="fc"><i>543</i>&nbsp;            c = skip_over_whitespace();</b>
<b class="fc"><i>544</i>&nbsp;            break;</b>
<i>545</i>&nbsp;
<i>546</i>&nbsp;        case IonTokenConstsX.TOKEN_OPEN_DOUBLE_BRACE:
<i>547</i>&nbsp;            // works just like a pair of nested structs
<i>548</i>&nbsp;            // since &quot;skip_over&quot; doesn&#39;t care about formal
<i>549</i>&nbsp;            // syntax (like requiring field names);
<b class="fc"><i>550</i>&nbsp;            skip_over_blob(sp);</b>
<b class="fc"><i>551</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>552</i>&nbsp;            break;</b>
<i>553</i>&nbsp;        case IonTokenConstsX.TOKEN_OPEN_BRACE:
<b class="fc"><i>554</i>&nbsp;            assert( sp == null ); // you can&#39;t save point a scanned struct (right now anyway)</b>
<b class="fc"><i>555</i>&nbsp;            skip_over_struct();</b>
<b class="fc"><i>556</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>557</i>&nbsp;            break;</b>
<i>558</i>&nbsp;        case IonTokenConstsX.TOKEN_OPEN_PAREN:
<b class="fc"><i>559</i>&nbsp;            skip_over_sexp(); // you can&#39;t save point a scanned sexp (right now anyway)</b>
<b class="fc"><i>560</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>561</i>&nbsp;            break;</b>
<i>562</i>&nbsp;        case IonTokenConstsX.TOKEN_OPEN_SQUARE:
<b class="fc"><i>563</i>&nbsp;            skip_over_list();  // you can&#39;t save point a scanned list (right now anyway)</b>
<b class="fc"><i>564</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>565</i>&nbsp;            break;</b>
<i>566</i>&nbsp;        case IonTokenConstsX.TOKEN_DOT:
<i>567</i>&nbsp;        case IonTokenConstsX.TOKEN_COMMA:
<i>568</i>&nbsp;        case IonTokenConstsX.TOKEN_COLON:
<i>569</i>&nbsp;        case IonTokenConstsX.TOKEN_DOUBLE_COLON:
<i>570</i>&nbsp;        case IonTokenConstsX.TOKEN_CLOSE_PAREN:
<i>571</i>&nbsp;        case IonTokenConstsX.TOKEN_CLOSE_BRACE:
<i>572</i>&nbsp;        case IonTokenConstsX.TOKEN_CLOSE_SQUARE:
<i>573</i>&nbsp;        case IonTokenConstsX.TOKEN_CLOSE_DOUBLE_BRACE:
<i>574</i>&nbsp;        case IonTokenConstsX.TOKEN_ERROR:
<i>575</i>&nbsp;        case IonTokenConstsX.TOKEN_EOF:
<i>576</i>&nbsp;        default:
<b class="nc"><i>577</i>&nbsp;            c = -1; // makes eclipse happy</b>
<b class="nc"><i>578</i>&nbsp;            error(&quot;token &quot;+IonTokenConstsX.getTokenName(_token)+</b>
<i>579</i>&nbsp;                  &quot; unexpectedly encounterd as \&quot;unfinished\&quot;&quot;);
<i>580</i>&nbsp;            break;
<i>581</i>&nbsp;        }
<b class="fc"><i>582</i>&nbsp;        if (IonTokenConstsX.isWhitespace(c)) {</b>
<b class="fc"><i>583</i>&nbsp;            c = skip_over_whitespace();</b>
<i>584</i>&nbsp;        }
<b class="fc"><i>585</i>&nbsp;        _unfinished_token = false;</b>
<b class="fc"><i>586</i>&nbsp;        return c;</b>
<i>587</i>&nbsp;    }
<i>588</i>&nbsp;
<i>589</i>&nbsp;    public final long getStartingOffset() throws IOException
<i>590</i>&nbsp;    {
<i>591</i>&nbsp;        int c;
<b class="fc"><i>592</i>&nbsp;        if (_unfinished_token) {</b>
<b class="nc"><i>593</i>&nbsp;            c = skip_to_end(null);</b>
<i>594</i>&nbsp;        }
<i>595</i>&nbsp;        else {
<b class="fc"><i>596</i>&nbsp;            c = skip_over_whitespace();</b>
<i>597</i>&nbsp;        }
<b class="fc"><i>598</i>&nbsp;        unread_char(c);</b>
<b class="fc"><i>599</i>&nbsp;        long pos = _stream.getPosition();</b>
<b class="fc"><i>600</i>&nbsp;        return pos;</b>
<i>601</i>&nbsp;    }
<i>602</i>&nbsp;
<i>603</i>&nbsp;    public final int nextToken() throws IOException
<i>604</i>&nbsp;    {
<b class="fc"><i>605</i>&nbsp;        int t = -1;</b>
<i>606</i>&nbsp;        int c, c2;
<i>607</i>&nbsp;
<b class="fc"><i>608</i>&nbsp;        if (_unfinished_token) {</b>
<b class="nc"><i>609</i>&nbsp;            c = skip_to_end(null);</b>
<i>610</i>&nbsp;        }
<i>611</i>&nbsp;        else {
<b class="fc"><i>612</i>&nbsp;            c = skip_over_whitespace();</b>
<i>613</i>&nbsp;        }
<b class="fc"><i>614</i>&nbsp;        _unfinished_token = true;</b>
<i>615</i>&nbsp;
<b class="fc"><i>616</i>&nbsp;        switch (c) {</b>
<i>617</i>&nbsp;        case -1:
<b class="fc"><i>618</i>&nbsp;            return next_token_finish(IonTokenConstsX.TOKEN_EOF, true);</b>
<i>619</i>&nbsp;        case &#39;/&#39;:
<b class="fc"><i>620</i>&nbsp;            unread_char(c);</b>
<b class="fc"><i>621</i>&nbsp;            return next_token_finish(IonTokenConstsX.TOKEN_SYMBOL_OPERATOR, true);</b>
<i>622</i>&nbsp;        case &#39;:&#39;:
<b class="fc"><i>623</i>&nbsp;            c2 = read_char();</b>
<b class="fc"><i>624</i>&nbsp;            if (c2 != &#39;:&#39;) {</b>
<b class="fc"><i>625</i>&nbsp;                unread_char(c2);</b>
<b class="fc"><i>626</i>&nbsp;                return next_token_finish(IonTokenConstsX.TOKEN_COLON, true);</b>
<i>627</i>&nbsp;            }
<b class="fc"><i>628</i>&nbsp;            return next_token_finish(IonTokenConstsX.TOKEN_DOUBLE_COLON, true);</b>
<i>629</i>&nbsp;        case &#39;{&#39;:
<b class="fc"><i>630</i>&nbsp;            c2 = read_char();</b>
<b class="fc"><i>631</i>&nbsp;            if (c2 != &#39;{&#39;) {</b>
<b class="fc"><i>632</i>&nbsp;                unread_char(c2);</b>
<b class="fc"><i>633</i>&nbsp;                return next_token_finish(IonTokenConstsX.TOKEN_OPEN_BRACE, true); // CAS: 9 nov 2009</b>
<i>634</i>&nbsp;            }
<b class="fc"><i>635</i>&nbsp;            return next_token_finish(IonTokenConstsX.TOKEN_OPEN_DOUBLE_BRACE, true);</b>
<i>636</i>&nbsp;        case &#39;}&#39;:
<i>637</i>&nbsp;            // detection of double closing braces is done
<i>638</i>&nbsp;            // in the parser in the blob and clob handling
<i>639</i>&nbsp;            // state - it&#39;s otherwise ambiguous with closing
<i>640</i>&nbsp;            // two structs together. see tryForDoubleBrace() below
<b class="fc"><i>641</i>&nbsp;            return next_token_finish(IonTokenConstsX.TOKEN_CLOSE_BRACE, false);</b>
<i>642</i>&nbsp;        case &#39;[&#39;:
<b class="fc"><i>643</i>&nbsp;            return next_token_finish(IonTokenConstsX.TOKEN_OPEN_SQUARE, true); // CAS: 9 nov 2009</b>
<i>644</i>&nbsp;        case &#39;]&#39;:
<b class="fc"><i>645</i>&nbsp;            return next_token_finish(IonTokenConstsX.TOKEN_CLOSE_SQUARE, false);</b>
<i>646</i>&nbsp;        case &#39;(&#39;:
<b class="fc"><i>647</i>&nbsp;            return next_token_finish(IonTokenConstsX.TOKEN_OPEN_PAREN, true); // CAS: 9 nov 2009</b>
<i>648</i>&nbsp;        case &#39;)&#39;:
<b class="fc"><i>649</i>&nbsp;            return next_token_finish(IonTokenConstsX.TOKEN_CLOSE_PAREN, false);</b>
<i>650</i>&nbsp;        case &#39;,&#39;:
<b class="fc"><i>651</i>&nbsp;            return next_token_finish(IonTokenConstsX.TOKEN_COMMA, false);</b>
<i>652</i>&nbsp;        case &#39;.&#39;:
<b class="fc"><i>653</i>&nbsp;            c2 = read_char();</b>
<b class="fc"><i>654</i>&nbsp;            unread_char(c2);</b>
<b class="fc"><i>655</i>&nbsp;            if (IonTokenConstsX.isValidExtendedSymbolCharacter(c2)) {</b>
<b class="nc"><i>656</i>&nbsp;                unread_char(&#39;.&#39;);</b>
<b class="nc"><i>657</i>&nbsp;                return next_token_finish(IonTokenConstsX.TOKEN_SYMBOL_OPERATOR, true);</b>
<i>658</i>&nbsp;            }
<b class="fc"><i>659</i>&nbsp;            return next_token_finish(IonTokenConstsX.TOKEN_DOT, false);</b>
<i>660</i>&nbsp;        case &#39;\&#39;&#39;:
<b class="fc"><i>661</i>&nbsp;            if (is_2_single_quotes_helper()) {</b>
<b class="fc"><i>662</i>&nbsp;                return next_token_finish(IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE, true);</b>
<i>663</i>&nbsp;            }
<i>664</i>&nbsp;            // unread_char(c);
<b class="fc"><i>665</i>&nbsp;            return next_token_finish(IonTokenConstsX.TOKEN_SYMBOL_QUOTED, true);</b>
<i>666</i>&nbsp;        case &#39;+&#39;:
<b class="fc"><i>667</i>&nbsp;            if (peek_inf_helper(c)) // this will consume the inf if it succeeds</b>
<i>668</i>&nbsp;            {
<b class="fc"><i>669</i>&nbsp;                return next_token_finish(IonTokenConstsX.TOKEN_FLOAT_INF, false);</b>
<i>670</i>&nbsp;            }
<b class="fc"><i>671</i>&nbsp;            unread_char(c);</b>
<b class="fc"><i>672</i>&nbsp;            return next_token_finish(IonTokenConstsX.TOKEN_SYMBOL_OPERATOR, true);</b>
<i>673</i>&nbsp;        case &#39;#&#39;:
<i>674</i>&nbsp;        case &#39;&lt;&#39;: case &#39;&gt;&#39;: case &#39;*&#39;: case &#39;=&#39;: case &#39;^&#39;: case &#39;&amp;&#39;: case &#39;|&#39;:
<i>675</i>&nbsp;        case &#39;~&#39;: case &#39;;&#39;: case &#39;!&#39;: case &#39;?&#39;: case &#39;@&#39;: case &#39;%&#39;: case &#39;`&#39;:
<b class="fc"><i>676</i>&nbsp;            unread_char(c);</b>
<b class="fc"><i>677</i>&nbsp;            return next_token_finish(IonTokenConstsX.TOKEN_SYMBOL_OPERATOR, true);</b>
<i>678</i>&nbsp;        case &#39;&quot;&#39;:
<b class="fc"><i>679</i>&nbsp;            return next_token_finish(IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE, true);</b>
<i>680</i>&nbsp;        case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;: case &#39;f&#39;:
<i>681</i>&nbsp;        case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;: case &#39;k&#39;: case &#39;l&#39;:
<i>682</i>&nbsp;        case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;: case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;:
<i>683</i>&nbsp;        case &#39;s&#39;: case &#39;t&#39;: case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;:
<i>684</i>&nbsp;        case &#39;y&#39;: case &#39;z&#39;:
<i>685</i>&nbsp;        case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;: case &#39;F&#39;:
<i>686</i>&nbsp;        case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;: case &#39;K&#39;: case &#39;L&#39;:
<i>687</i>&nbsp;        case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;: case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;:
<i>688</i>&nbsp;        case &#39;S&#39;: case &#39;T&#39;: case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;:
<i>689</i>&nbsp;        case &#39;Y&#39;: case &#39;Z&#39;:
<i>690</i>&nbsp;        case &#39;$&#39;: case &#39;_&#39;:
<b class="fc"><i>691</i>&nbsp;            unread_char(c);</b>
<b class="fc"><i>692</i>&nbsp;            return next_token_finish(IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER, true);</b>
<i>693</i>&nbsp;        case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
<i>694</i>&nbsp;        case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
<b class="fc"><i>695</i>&nbsp;            t = scan_for_numeric_type(c);</b>
<b class="fc"><i>696</i>&nbsp;            unread_char(c);</b>
<b class="fc"><i>697</i>&nbsp;            return next_token_finish(t, true);</b>
<i>698</i>&nbsp;        case &#39;-&#39;:
<i>699</i>&nbsp;            // see if we have a number or what might be an extended symbol
<b class="fc"><i>700</i>&nbsp;            c2 = read_char();</b>
<b class="fc"><i>701</i>&nbsp;            unread_char(c2);</b>
<b class="fc"><i>702</i>&nbsp;            if (IonTokenConstsX.isDigit(c2)) {</b>
<b class="fc"><i>703</i>&nbsp;                t = scan_negative_for_numeric_type(c);</b>
<b class="fc"><i>704</i>&nbsp;                unread_char(c);</b>
<b class="fc"><i>705</i>&nbsp;                return next_token_finish(t, true);</b>
<i>706</i>&nbsp;            }
<b class="fc"><i>707</i>&nbsp;            else if (peek_inf_helper(c)) // this will consume the inf if it succeeds</b>
<i>708</i>&nbsp;            {
<b class="fc"><i>709</i>&nbsp;                return next_token_finish(IonTokenConstsX.TOKEN_FLOAT_MINUS_INF, false);</b>
<i>710</i>&nbsp;            }
<i>711</i>&nbsp;            else {
<b class="fc"><i>712</i>&nbsp;                unread_char(c);</b>
<b class="fc"><i>713</i>&nbsp;                return next_token_finish(IonTokenConstsX.TOKEN_SYMBOL_OPERATOR, true);</b>
<i>714</i>&nbsp;            }
<i>715</i>&nbsp;        default:
<b class="fc"><i>716</i>&nbsp;            bad_token_start(c); // throws</b>
<i>717</i>&nbsp;        }
<b class="nc"><i>718</i>&nbsp;        throw new IonException(&quot;invalid state: next token switch shouldn&#39;t exit&quot;);</b>
<i>719</i>&nbsp;    }
<i>720</i>&nbsp;    private final int next_token_finish(int token, boolean content_is_waiting) {
<b class="fc"><i>721</i>&nbsp;        _token = token;</b>
<b class="fc"><i>722</i>&nbsp;        _unfinished_token = content_is_waiting;</b>
<b class="fc"><i>723</i>&nbsp;        return _token;</b>
<i>724</i>&nbsp;    }
<i>725</i>&nbsp;
<i>726</i>&nbsp;    /**
<i>727</i>&nbsp;     * Defines strategies to apply when comments are encountered.
<i>728</i>&nbsp;     */
<b class="fc"><i>729</i>&nbsp;    private enum CommentStrategy</b>
<i>730</i>&nbsp;    {
<i>731</i>&nbsp;        /**
<i>732</i>&nbsp;         * Skip over all of the comment&#39;s text.
<i>733</i>&nbsp;         */
<b class="fc"><i>734</i>&nbsp;        IGNORE</b>
<i>735</i>&nbsp;        {
<i>736</i>&nbsp;
<i>737</i>&nbsp;            @Override
<i>738</i>&nbsp;            boolean onComment(IonReaderTextRawTokensX tokenizer)
<i>739</i>&nbsp;                throws IOException
<i>740</i>&nbsp;            {
<b class="fc"><i>741</i>&nbsp;                int next = tokenizer.read_char();</b>
<b class="fc"><i>742</i>&nbsp;                switch(next) {</b>
<i>743</i>&nbsp;                case &#39;/&#39;:
<b class="fc"><i>744</i>&nbsp;                    tokenizer.skip_single_line_comment();</b>
<b class="fc"><i>745</i>&nbsp;                    return true; // valid comment</b>
<i>746</i>&nbsp;                case &#39;*&#39;:
<b class="fc"><i>747</i>&nbsp;                    tokenizer.skip_block_comment();</b>
<b class="fc"><i>748</i>&nbsp;                    return true; // valid comment</b>
<i>749</i>&nbsp;                default:
<b class="fc"><i>750</i>&nbsp;                    tokenizer.unread_char(next);</b>
<b class="fc"><i>751</i>&nbsp;                    return false; // invalid comment</b>
<i>752</i>&nbsp;                }
<i>753</i>&nbsp;            }
<i>754</i>&nbsp;
<i>755</i>&nbsp;        },
<i>756</i>&nbsp;        /**
<i>757</i>&nbsp;         * If it&#39;s a valid comment, throw an error.
<i>758</i>&nbsp;         */
<b class="fc"><i>759</i>&nbsp;        ERROR</b>
<i>760</i>&nbsp;        {
<i>761</i>&nbsp;
<i>762</i>&nbsp;            @Override
<i>763</i>&nbsp;            boolean onComment(IonReaderTextRawTokensX tokenizer)
<i>764</i>&nbsp;                throws IOException
<i>765</i>&nbsp;            {
<b class="fc"><i>766</i>&nbsp;                int next = tokenizer.read_char();</b>
<b class="fc"><i>767</i>&nbsp;                if (next == &#39;/&#39; || next == &#39;*&#39;)</b>
<i>768</i>&nbsp;                {
<b class="fc"><i>769</i>&nbsp;                    tokenizer.error(&quot;Illegal comment&quot;);</b>
<i>770</i>&nbsp;                }
<i>771</i>&nbsp;                else
<i>772</i>&nbsp;                {
<b class="nc"><i>773</i>&nbsp;                    tokenizer.unread_char(next);</b>
<i>774</i>&nbsp;                }
<b class="nc"><i>775</i>&nbsp;                return false; // invalid comment</b>
<i>776</i>&nbsp;            }
<i>777</i>&nbsp;
<i>778</i>&nbsp;        },
<i>779</i>&nbsp;        /**
<i>780</i>&nbsp;         * A &#39;/&#39; character has been found, so break the loop as it may be a valid blob character.
<i>781</i>&nbsp;         */
<b class="fc"><i>782</i>&nbsp;        BREAK</b>
<i>783</i>&nbsp;        {
<i>784</i>&nbsp;
<i>785</i>&nbsp;            @Override
<i>786</i>&nbsp;            boolean onComment(IonReaderTextRawTokensX tokenizer)
<i>787</i>&nbsp;                throws IOException
<i>788</i>&nbsp;            {
<b class="fc"><i>789</i>&nbsp;                return false;</b>
<i>790</i>&nbsp;            }
<i>791</i>&nbsp;
<i>792</i>&nbsp;        };
<i>793</i>&nbsp;
<i>794</i>&nbsp;        /**
<i>795</i>&nbsp;         * Called when positioned after the first &#39;/&#39;.
<i>796</i>&nbsp;         * @return true if a valid comment was found, otherwise false
<i>797</i>&nbsp;         * @throws IonReaderTextTokenException when the ERROR strategy encounters a comment
<i>798</i>&nbsp;         */
<i>799</i>&nbsp;        abstract boolean onComment(IonReaderTextRawTokensX tokenizer) throws IOException;
<i>800</i>&nbsp;    }
<i>801</i>&nbsp;
<i>802</i>&nbsp;    /**
<i>803</i>&nbsp;     * Skip over any whitespace, ignoring any comments.
<i>804</i>&nbsp;     * @return the next character in the stream
<i>805</i>&nbsp;     * @throws IOException
<i>806</i>&nbsp;     */
<i>807</i>&nbsp;    private final int skip_over_whitespace() throws IOException
<i>808</i>&nbsp;    {
<b class="fc"><i>809</i>&nbsp;        return skip_over_whitespace(CommentStrategy.IGNORE);</b>
<i>810</i>&nbsp;    }
<i>811</i>&nbsp;
<i>812</i>&nbsp;    /**
<i>813</i>&nbsp;     * Skip over any whitespace, applying the given CommentStrategy to
<i>814</i>&nbsp;     * any comments found.
<i>815</i>&nbsp;     * @param commentStrategy the strategy to use upon encountering comments.
<i>816</i>&nbsp;     * @return the next character in the stream
<i>817</i>&nbsp;     * @throws IOException
<i>818</i>&nbsp;     */
<i>819</i>&nbsp;    private final int skip_over_whitespace(CommentStrategy commentStrategy) throws IOException
<i>820</i>&nbsp;    {
<b class="fc"><i>821</i>&nbsp;        skip_whitespace(commentStrategy);</b>
<b class="fc"><i>822</i>&nbsp;        return read_char();</b>
<i>823</i>&nbsp;    }
<i>824</i>&nbsp;
<i>825</i>&nbsp;    /**
<i>826</i>&nbsp;     * The type of lob is not yet known. Break the loop on encountering
<i>827</i>&nbsp;     * a / character and defer to the blob validation.
<i>828</i>&nbsp;     * @return the next character in the stream
<i>829</i>&nbsp;     * @throws IOException
<i>830</i>&nbsp;     */
<i>831</i>&nbsp;    private final int skip_over_lob_whitespace() throws IOException
<i>832</i>&nbsp;    {
<b class="fc"><i>833</i>&nbsp;        return skip_over_blob_whitespace();</b>
<i>834</i>&nbsp;    }
<i>835</i>&nbsp;
<i>836</i>&nbsp;    /**
<i>837</i>&nbsp;     * Skip over whitespace, but not the / character, as it&#39;s a valid
<i>838</i>&nbsp;     * Base64 character.
<i>839</i>&nbsp;     * @return the next character in the stream
<i>840</i>&nbsp;     * @throws IOException
<i>841</i>&nbsp;     */
<i>842</i>&nbsp;    private final int skip_over_blob_whitespace() throws IOException
<i>843</i>&nbsp;    {
<b class="fc"><i>844</i>&nbsp;        return skip_over_whitespace(CommentStrategy.BREAK);</b>
<i>845</i>&nbsp;    }
<i>846</i>&nbsp;
<i>847</i>&nbsp;    /**
<i>848</i>&nbsp;     * Skip over the whitespace after the clob string and before the closing
<i>849</i>&nbsp;     * braces. Throw if a comment is encountered.
<i>850</i>&nbsp;     * @return the next character in the stream
<i>851</i>&nbsp;     * @throws IOException
<i>852</i>&nbsp;     */
<i>853</i>&nbsp;    private final int skip_over_clob_whitespace() throws IOException
<i>854</i>&nbsp;    {
<b class="fc"><i>855</i>&nbsp;        return skip_over_whitespace(CommentStrategy.ERROR);</b>
<i>856</i>&nbsp;    }
<i>857</i>&nbsp;
<i>858</i>&nbsp;    /**
<i>859</i>&nbsp;     * Skips whitespace and comments and finishes at the starting position
<i>860</i>&nbsp;     * of the next token.
<i>861</i>&nbsp;     * @return true if whitespace or comments were encountered
<i>862</i>&nbsp;     * @throws IOException
<i>863</i>&nbsp;     */
<i>864</i>&nbsp;    protected final boolean skip_whitespace() throws IOException
<i>865</i>&nbsp;    {
<b class="fc"><i>866</i>&nbsp;        return skip_whitespace(CommentStrategy.IGNORE);</b>
<i>867</i>&nbsp;    }
<i>868</i>&nbsp;
<i>869</i>&nbsp;    /**
<i>870</i>&nbsp;     * Skips whitespace and applies the given CommentStrategy to any comments
<i>871</i>&nbsp;     * found. Finishes at the starting position of the next token.
<i>872</i>&nbsp;     * @param commentStrategy
<i>873</i>&nbsp;     * @return true if whitespace was skipped and/or comments ignored
<i>874</i>&nbsp;     * @throws IOException
<i>875</i>&nbsp;     */
<i>876</i>&nbsp;    private final boolean skip_whitespace(CommentStrategy commentStrategy) throws IOException
<i>877</i>&nbsp;    {
<b class="fc"><i>878</i>&nbsp;        boolean any_whitespace = false;</b>
<i>879</i>&nbsp;        int c;
<i>880</i>&nbsp;
<i>881</i>&nbsp;        loop: for (;;) {
<b class="fc"><i>882</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>883</i>&nbsp;            switch (c) {</b>
<i>884</i>&nbsp;            case -1:
<b class="fc"><i>885</i>&nbsp;                break loop;</b>
<i>886</i>&nbsp;            case &#39; &#39;:
<i>887</i>&nbsp;            case &#39;\t&#39;:
<i>888</i>&nbsp;            // new line normalization and counting is handled in read_char
<i>889</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
<i>890</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
<i>891</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
<i>892</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
<i>893</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
<i>894</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
<b class="fc"><i>895</i>&nbsp;                any_whitespace = true;</b>
<b class="fc"><i>896</i>&nbsp;                break;</b>
<i>897</i>&nbsp;            case &#39;/&#39;:
<b class="fc"><i>898</i>&nbsp;                if (!commentStrategy.onComment(this))</b>
<i>899</i>&nbsp;                {
<b class="fc"><i>900</i>&nbsp;                    break loop;</b>
<i>901</i>&nbsp;                }
<b class="fc"><i>902</i>&nbsp;                any_whitespace = true;</b>
<b class="fc"><i>903</i>&nbsp;                break;</b>
<i>904</i>&nbsp;            default:
<b class="fc"><i>905</i>&nbsp;                break loop;</b>
<i>906</i>&nbsp;            }
<i>907</i>&nbsp;        }
<b class="fc"><i>908</i>&nbsp;        unread_char(c);</b>
<b class="fc"><i>909</i>&nbsp;        return any_whitespace;</b>
<i>910</i>&nbsp;    }
<i>911</i>&nbsp;
<i>912</i>&nbsp;    private final void skip_single_line_comment() throws IOException
<i>913</i>&nbsp;    {
<i>914</i>&nbsp;        for (;;) {
<b class="fc"><i>915</i>&nbsp;            int c = read_char();</b>
<b class="fc"><i>916</i>&nbsp;            switch (c) {</b>
<i>917</i>&nbsp;            // new line normalization and counting is handled in read_char
<i>918</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
<i>919</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
<i>920</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
<i>921</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
<i>922</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
<i>923</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
<b class="fc"><i>924</i>&nbsp;                return;</b>
<i>925</i>&nbsp;            case -1:
<b class="fc"><i>926</i>&nbsp;                return;</b>
<i>927</i>&nbsp;            default:
<i>928</i>&nbsp;                break; // and read another character
<i>929</i>&nbsp;            }
<b class="fc"><i>930</i>&nbsp;        }</b>
<i>931</i>&nbsp;    }
<i>932</i>&nbsp;
<i>933</i>&nbsp;    private final void skip_block_comment() throws IOException
<i>934</i>&nbsp;    {
<i>935</i>&nbsp;        int c;
<i>936</i>&nbsp;        for (;;) {
<b class="fc"><i>937</i>&nbsp;            c = this.read_char();</b>
<b class="fc"><i>938</i>&nbsp;            switch (c) {</b>
<i>939</i>&nbsp;                case &#39;*&#39;:
<i>940</i>&nbsp;                    // read back to back &#39;*&#39;s until you hit a &#39;/&#39; and terminate the comment
<i>941</i>&nbsp;                    // or you see a non-&#39;*&#39;; in which case you go back to the outer loop.
<i>942</i>&nbsp;                    // this just avoids the read-unread pattern on every &#39;*&#39; in a line of &#39;*&#39;
<i>943</i>&nbsp;                    // commonly found at the top and bottom of block comments
<i>944</i>&nbsp;                    for (;;) {
<b class="fc"><i>945</i>&nbsp;                        c = this.read_char();</b>
<b class="fc"><i>946</i>&nbsp;                        if (c == &#39;/&#39;) return;</b>
<b class="fc"><i>947</i>&nbsp;                        if (c != &#39;*&#39;) break;</b>
<i>948</i>&nbsp;                    }
<i>949</i>&nbsp;                    break;
<i>950</i>&nbsp;                case -1:
<b class="nc"><i>951</i>&nbsp;                    bad_token_start(c);</b>
<i>952</i>&nbsp;                default:
<b class="fc"><i>953</i>&nbsp;                    break;</b>
<i>954</i>&nbsp;            }
<i>955</i>&nbsp;        }
<i>956</i>&nbsp;    }
<i>957</i>&nbsp;
<i>958</i>&nbsp;    /**
<i>959</i>&nbsp;     * this peeks ahead to see if the next two characters
<i>960</i>&nbsp;     * are single quotes. this would finish off a triple
<i>961</i>&nbsp;     * quote when the first quote has been read.
<i>962</i>&nbsp;     * if it succeeds it &quot;consumes&quot; the two quotes
<i>963</i>&nbsp;     * it reads.
<i>964</i>&nbsp;     * if it fails it unreads
<i>965</i>&nbsp;     * @return true if the next two characters are single quotes
<i>966</i>&nbsp;     * @throws IOException
<i>967</i>&nbsp;     */
<i>968</i>&nbsp;    private final boolean is_2_single_quotes_helper() throws IOException
<i>969</i>&nbsp;    {
<b class="fc"><i>970</i>&nbsp;        int c = read_char();</b>
<b class="fc"><i>971</i>&nbsp;        if (c != &#39;\&#39;&#39;) {</b>
<b class="fc"><i>972</i>&nbsp;            unread_char(c);</b>
<b class="fc"><i>973</i>&nbsp;            return false;</b>
<i>974</i>&nbsp;        }
<b class="fc"><i>975</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>976</i>&nbsp;        if (c != &#39;\&#39;&#39;) {</b>
<b class="fc"><i>977</i>&nbsp;            unread_char(c);</b>
<b class="fc"><i>978</i>&nbsp;            unread_char(&#39;\&#39;&#39;);</b>
<b class="fc"><i>979</i>&nbsp;            return false;</b>
<i>980</i>&nbsp;        }
<b class="fc"><i>981</i>&nbsp;        return true;</b>
<i>982</i>&nbsp;    }
<i>983</i>&nbsp;
<i>984</i>&nbsp;    private final boolean peek_inf_helper(int c) throws IOException
<i>985</i>&nbsp;    {
<b class="fc"><i>986</i>&nbsp;        if (c != &#39;+&#39; &amp;&amp; c != &#39;-&#39;) return false;</b>
<b class="fc"><i>987</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>988</i>&nbsp;        if (c == &#39;i&#39;) {</b>
<b class="fc"><i>989</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>990</i>&nbsp;            if (c == &#39;n&#39;) {</b>
<b class="fc"><i>991</i>&nbsp;                c = read_char();</b>
<b class="fc"><i>992</i>&nbsp;                if (c == &#39;f&#39;) {</b>
<b class="fc"><i>993</i>&nbsp;                    c = read_char();</b>
<b class="fc"><i>994</i>&nbsp;                    if (is_value_terminating_character(c)) {</b>
<b class="fc"><i>995</i>&nbsp;                        unread_char(c);</b>
<b class="fc"><i>996</i>&nbsp;                        return true;</b>
<i>997</i>&nbsp;                    }
<b class="nc"><i>998</i>&nbsp;                    unread_char(c);</b>
<b class="nc"><i>999</i>&nbsp;                    c = &#39;f&#39;;</b>
<i>1000</i>&nbsp;                }
<b class="nc"><i>1001</i>&nbsp;                unread_char(c);</b>
<b class="nc"><i>1002</i>&nbsp;                c = &#39;n&#39;;</b>
<i>1003</i>&nbsp;            }
<b class="nc"><i>1004</i>&nbsp;            unread_char(c);</b>
<b class="nc"><i>1005</i>&nbsp;            c = &#39;i&#39;;</b>
<i>1006</i>&nbsp;        }
<b class="fc"><i>1007</i>&nbsp;        unread_char(c);</b>
<b class="fc"><i>1008</i>&nbsp;        return false;</b>
<i>1009</i>&nbsp;    }
<i>1010</i>&nbsp;
<i>1011</i>&nbsp;    /**
<i>1012</i>&nbsp;     * we encountered a character that starts a number,
<i>1013</i>&nbsp;     * a digit or a dash (minus).  Now we&#39;ll scan a little
<i>1014</i>&nbsp;     * ways ahead to spot some of the numeric types.
<i>1015</i>&nbsp;     *
<i>1016</i>&nbsp;     * this only looks far enough (2 or 6 chars) to identify
<i>1017</i>&nbsp;     * hex and timestamps
<i>1018</i>&nbsp;     * it might encounter a decimal or a &#39;d&#39; or an &#39;e&#39; and
<i>1019</i>&nbsp;     * decide this token is float or decimal (or int if we
<i>1020</i>&nbsp;     * hit a non-numeric char) but it may return TOKEN_UNKNOWN_NUMERIC;
<i>1021</i>&nbsp;     *
<i>1022</i>&nbsp;     * if will unread everything it&#39;s read, and the character
<i>1023</i>&nbsp;     * passed in as the first digit encountered
<i>1024</i>&nbsp;     *
<i>1025</i>&nbsp;     * @param c first char of number read by caller
<i>1026</i>&nbsp;     * @return numeric token type
<i>1027</i>&nbsp;     * @throws IOException
<i>1028</i>&nbsp;     */
<i>1029</i>&nbsp;    private final int scan_for_numeric_type(int c1) throws IOException
<i>1030</i>&nbsp;    {
<b class="fc"><i>1031</i>&nbsp;        int   t = IonTokenConstsX.TOKEN_UNKNOWN_NUMERIC;</b>
<b class="fc"><i>1032</i>&nbsp;        int[] read_chars = new int[6];</b>
<b class="fc"><i>1033</i>&nbsp;        int   read_char_count = 0;</b>
<i>1034</i>&nbsp;        int   c;
<i>1035</i>&nbsp;
<b class="fc"><i>1036</i>&nbsp;        if (!IonTokenConstsX.isDigit(c1)) {</b>
<b class="nc"><i>1037</i>&nbsp;            error(String.format(&quot;Expected digit, got U+%04X&quot;, c1));</b>
<i>1038</i>&nbsp;        }
<i>1039</i>&nbsp;
<i>1040</i>&nbsp;        // the caller needs to unread this if they want to: read_chars[read_char_count++] = c1;
<i>1041</i>&nbsp;
<b class="fc"><i>1042</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>1043</i>&nbsp;        read_chars[read_char_count++] = c;</b>
<i>1044</i>&nbsp;
<b class="fc"><i>1045</i>&nbsp;        if (c1 == &#39;0&#39;) {</b>
<i>1046</i>&nbsp;            // check for hex
<b class="fc"><i>1047</i>&nbsp;            switch(c) {</b>
<i>1048</i>&nbsp;            case &#39;x&#39;:
<i>1049</i>&nbsp;            case &#39;X&#39;:
<b class="fc"><i>1050</i>&nbsp;                t = IonTokenConstsX.TOKEN_HEX;</b>
<b class="fc"><i>1051</i>&nbsp;                break;</b>
<i>1052</i>&nbsp;            case &#39;d&#39;:
<i>1053</i>&nbsp;            case &#39;D&#39;:
<b class="fc"><i>1054</i>&nbsp;                t = IonTokenConstsX.TOKEN_DECIMAL;</b>
<b class="fc"><i>1055</i>&nbsp;                break;</b>
<i>1056</i>&nbsp;            case &#39;e&#39;:
<i>1057</i>&nbsp;            case &#39;E&#39;:
<b class="fc"><i>1058</i>&nbsp;                t = IonTokenConstsX.TOKEN_FLOAT;</b>
<b class="fc"><i>1059</i>&nbsp;                break;</b>
<i>1060</i>&nbsp;            case &#39;b&#39;:
<i>1061</i>&nbsp;            case &#39;B&#39;:
<b class="fc"><i>1062</i>&nbsp;                t = IonTokenConstsX.TOKEN_BINARY;</b>
<b class="fc"><i>1063</i>&nbsp;                break;</b>
<i>1064</i>&nbsp;            case &#39;.&#39;:
<i>1065</i>&nbsp;                // the decimal might have an &#39;e&#39; somewhere down the line so we
<i>1066</i>&nbsp;                // don&#39;t really know the type here
<b class="fc"><i>1067</i>&nbsp;                break;</b>
<i>1068</i>&nbsp;            default:
<b class="fc"><i>1069</i>&nbsp;                if (is_value_terminating_character(c)) {</b>
<b class="fc"><i>1070</i>&nbsp;                    t = IonTokenConstsX.TOKEN_INT;</b>
<i>1071</i>&nbsp;                }
<i>1072</i>&nbsp;                break;
<i>1073</i>&nbsp;            }
<i>1074</i>&nbsp;        }
<b class="fc"><i>1075</i>&nbsp;        if (t == IonTokenConstsX.TOKEN_UNKNOWN_NUMERIC) { // oh for goto :(</b>
<b class="fc"><i>1076</i>&nbsp;            if (IonTokenConstsX.isDigit(c)) { // 2nd digit</b>
<i>1077</i>&nbsp;                // it might be a timestamp if we have 4 digits, a dash,
<i>1078</i>&nbsp;                // and a digit
<b class="fc"><i>1079</i>&nbsp;                c = read_char();</b>
<b class="fc"><i>1080</i>&nbsp;                read_chars[read_char_count++] = c;</b>
<b class="fc"><i>1081</i>&nbsp;                if (IonTokenConstsX.isDigit(c)) { // digit 3</b>
<b class="fc"><i>1082</i>&nbsp;                    c = read_char();</b>
<b class="fc"><i>1083</i>&nbsp;                    read_chars[read_char_count++] = c;</b>
<b class="fc"><i>1084</i>&nbsp;                    if (IonTokenConstsX.isDigit(c)) {</b>
<i>1085</i>&nbsp;                        // last digit of possible year
<b class="fc"><i>1086</i>&nbsp;                        c = read_char();</b>
<b class="fc"><i>1087</i>&nbsp;                        read_chars[read_char_count++] = c;</b>
<b class="fc"><i>1088</i>&nbsp;                        if (c == &#39;-&#39; || c ==&#39;T&#39;) {</b>
<i>1089</i>&nbsp;                            // we have dddd- or ddddT looks like a timestamp
<i>1090</i>&nbsp;                            // (or invalid input)
<b class="fc"><i>1091</i>&nbsp;                            t = IonTokenConstsX.TOKEN_TIMESTAMP;</b>
<i>1092</i>&nbsp;                        }
<i>1093</i>&nbsp;                    }
<i>1094</i>&nbsp;                }
<i>1095</i>&nbsp;            }
<i>1096</i>&nbsp;        }
<i>1097</i>&nbsp;
<i>1098</i>&nbsp;        // unread whatever we read, including the passed in char
<i>1099</i>&nbsp;        do {
<b class="fc"><i>1100</i>&nbsp;            read_char_count--;</b>
<b class="fc"><i>1101</i>&nbsp;            c = read_chars[read_char_count];</b>
<b class="fc"><i>1102</i>&nbsp;            unread_char(c);</b>
<b class="fc"><i>1103</i>&nbsp;        } while (read_char_count &gt; 0);</b>
<i>1104</i>&nbsp;
<b class="fc"><i>1105</i>&nbsp;        return t;</b>
<i>1106</i>&nbsp;    }
<i>1107</i>&nbsp;
<i>1108</i>&nbsp;    private final boolean is_value_terminating_character(int c)
<i>1109</i>&nbsp;        throws IOException
<i>1110</i>&nbsp;    {
<i>1111</i>&nbsp;        boolean isTerminator;
<i>1112</i>&nbsp;
<b class="fc"><i>1113</i>&nbsp;        switch (c) {</b>
<i>1114</i>&nbsp;            case &#39;/&#39;:
<i>1115</i>&nbsp;            // this is terminating only if it starts a comment of some sort
<b class="fc"><i>1116</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>1117</i>&nbsp;            unread_char(c);  // we never &quot;keep&quot; this character</b>
<b class="fc"><i>1118</i>&nbsp;            isTerminator = (c == &#39;/&#39; || c == &#39;*&#39;);</b>
<b class="fc"><i>1119</i>&nbsp;            break;</b>
<i>1120</i>&nbsp;        // new line normalization and counting is handled in read_char
<i>1121</i>&nbsp;        case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
<i>1122</i>&nbsp;        case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
<i>1123</i>&nbsp;        case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
<i>1124</i>&nbsp;        case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
<i>1125</i>&nbsp;        case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
<i>1126</i>&nbsp;        case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
<b class="fc"><i>1127</i>&nbsp;            isTerminator = true;</b>
<b class="fc"><i>1128</i>&nbsp;            break;</b>
<i>1129</i>&nbsp;        default:
<b class="fc"><i>1130</i>&nbsp;            isTerminator = IonTextUtils.isNumericStop(c);</b>
<i>1131</i>&nbsp;            break;
<i>1132</i>&nbsp;        }
<i>1133</i>&nbsp;
<b class="fc"><i>1134</i>&nbsp;        return isTerminator;</b>
<i>1135</i>&nbsp;    }
<i>1136</i>&nbsp;
<i>1137</i>&nbsp;    /**
<i>1138</i>&nbsp;     * variant of scan_numeric_type where the passed in
<i>1139</i>&nbsp;     * start character was preceded by a minus sign.
<i>1140</i>&nbsp;     * this will also unread the minus sign.
<i>1141</i>&nbsp;     *
<i>1142</i>&nbsp;     * @param c first char of number read by caller
<i>1143</i>&nbsp;     * @return numeric token type
<i>1144</i>&nbsp;     * @throws IOException
<i>1145</i>&nbsp;     */
<i>1146</i>&nbsp;    private final int scan_negative_for_numeric_type(int c) throws IOException
<i>1147</i>&nbsp;    {
<b class="fc"><i>1148</i>&nbsp;        assert(c == &#39;-&#39;);</b>
<b class="fc"><i>1149</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>1150</i>&nbsp;        int t = scan_for_numeric_type(c);</b>
<b class="fc"><i>1151</i>&nbsp;        if (t == IonTokenConstsX.TOKEN_TIMESTAMP) {</b>
<b class="fc"><i>1152</i>&nbsp;            bad_token(c);</b>
<i>1153</i>&nbsp;        }
<b class="fc"><i>1154</i>&nbsp;        unread_char(c); // and the caller need to unread the &#39;-&#39;</b>
<b class="fc"><i>1155</i>&nbsp;        return t;</b>
<i>1156</i>&nbsp;    }
<i>1157</i>&nbsp;
<i>1158</i>&nbsp;    // TODO: need new test cases since stepping out over values
<i>1159</i>&nbsp;    //       (or next-ing over them) is quite different from
<i>1160</i>&nbsp;    //       fully parsing them.  It is generally more lenient
<i>1161</i>&nbsp;    //       and that may not be best.
<i>1162</i>&nbsp;
<i>1163</i>&nbsp;    /**
<i>1164</i>&nbsp;     * this is used to load a previously marked set of bytes
<i>1165</i>&nbsp;     * into the StringBuilder without escaping.  It expects
<i>1166</i>&nbsp;     * the caller to have set a save point so that the EOF
<i>1167</i>&nbsp;     * will stop us at the right time.
<i>1168</i>&nbsp;     * This does handle UTF8 decoding and surrogate encoding
<i>1169</i>&nbsp;     * as the bytes are transfered.
<i>1170</i>&nbsp;     */
<i>1171</i>&nbsp;    protected void load_raw_characters(StringBuilder sb) throws IOException
<i>1172</i>&nbsp;    {
<b class="nc"><i>1173</i>&nbsp;        int c = read_char();</b>
<i>1174</i>&nbsp;        for (;;) {
<b class="nc"><i>1175</i>&nbsp;            c = read_char();</b>
<b class="nc"><i>1176</i>&nbsp;            switch (c) {</b>
<i>1177</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
<i>1178</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
<i>1179</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
<i>1180</i>&nbsp;            // WAS: case IonTokenConstsX.ESCAPED_NEWLINE_SEQUENCE:
<b class="nc"><i>1181</i>&nbsp;                continue;</b>
<i>1182</i>&nbsp;            case -1:
<b class="nc"><i>1183</i>&nbsp;                return;</b>
<i>1184</i>&nbsp;            default:
<b class="nc"><i>1185</i>&nbsp;                if (!IonTokenConstsX.is7bitValue(c)) {</b>
<b class="nc"><i>1186</i>&nbsp;                    c = read_large_char_sequence(c);</b>
<i>1187</i>&nbsp;                }
<i>1188</i>&nbsp;            }
<b class="nc"><i>1189</i>&nbsp;            if (IonUTF8.needsSurrogateEncoding(c)) {</b>
<b class="nc"><i>1190</i>&nbsp;                sb.append(IonUTF8.highSurrogate(c));</b>
<b class="nc"><i>1191</i>&nbsp;                c = IonUTF8.lowSurrogate(c);</b>
<i>1192</i>&nbsp;            }
<b class="nc"><i>1193</i>&nbsp;            sb.append((char)c);</b>
<i>1194</i>&nbsp;        }
<i>1195</i>&nbsp;    }
<i>1196</i>&nbsp;
<i>1197</i>&nbsp;    protected void skip_over_struct() throws IOException
<i>1198</i>&nbsp;    {
<b class="fc"><i>1199</i>&nbsp;        skip_over_container(&#39;}&#39;);</b>
<b class="fc"><i>1200</i>&nbsp;    }</b>
<i>1201</i>&nbsp;    protected void skip_over_list() throws IOException
<i>1202</i>&nbsp;    {
<b class="fc"><i>1203</i>&nbsp;        skip_over_container(&#39;]&#39;);</b>
<b class="fc"><i>1204</i>&nbsp;    }</b>
<i>1205</i>&nbsp;    protected void skip_over_sexp() throws IOException
<i>1206</i>&nbsp;    {
<b class="fc"><i>1207</i>&nbsp;        skip_over_container(&#39;)&#39;);</b>
<b class="fc"><i>1208</i>&nbsp;    }</b>
<i>1209</i>&nbsp;    private void skip_over_container(int terminator) throws IOException
<i>1210</i>&nbsp;    {
<b class="fc"><i>1211</i>&nbsp;        assert( terminator == &#39;}&#39; || terminator == &#39;]&#39; || terminator == &#39;)&#39; );</b>
<i>1212</i>&nbsp;        int c;
<i>1213</i>&nbsp;
<i>1214</i>&nbsp;        for (;;) {
<b class="fc"><i>1215</i>&nbsp;            c = skip_over_whitespace();</b>
<b class="fc"><i>1216</i>&nbsp;            switch (c) {</b>
<i>1217</i>&nbsp;            case -1:
<b class="nc"><i>1218</i>&nbsp;                unexpected_eof();</b>
<i>1219</i>&nbsp;            case &#39;}&#39;:
<i>1220</i>&nbsp;            case &#39;]&#39;:
<i>1221</i>&nbsp;            case &#39;)&#39;:
<b class="fc"><i>1222</i>&nbsp;                if (c == terminator) { // no point is checking this on every char</b>
<b class="fc"><i>1223</i>&nbsp;                    return;</b>
<i>1224</i>&nbsp;                }
<i>1225</i>&nbsp;                break;
<i>1226</i>&nbsp;            case &#39;&quot;&#39;:
<b class="fc"><i>1227</i>&nbsp;                skip_double_quoted_string_helper();</b>
<b class="fc"><i>1228</i>&nbsp;                break;</b>
<i>1229</i>&nbsp;            case &#39;\&#39;&#39;:
<b class="fc"><i>1230</i>&nbsp;                if (is_2_single_quotes_helper()) {</b>
<b class="fc"><i>1231</i>&nbsp;                    skip_triple_quoted_string(null);</b>
<i>1232</i>&nbsp;                }
<i>1233</i>&nbsp;                else {
<b class="fc"><i>1234</i>&nbsp;                    c = skip_single_quoted_string(null);</b>
<b class="fc"><i>1235</i>&nbsp;                    unread_char(c);</b>
<i>1236</i>&nbsp;                }
<b class="fc"><i>1237</i>&nbsp;                break;</b>
<i>1238</i>&nbsp;            case &#39;(&#39;:
<b class="fc"><i>1239</i>&nbsp;                skip_over_container(&#39;)&#39;);</b>
<b class="fc"><i>1240</i>&nbsp;                break;</b>
<i>1241</i>&nbsp;            case &#39;[&#39;:
<b class="fc"><i>1242</i>&nbsp;                skip_over_container(&#39;]&#39;);</b>
<b class="fc"><i>1243</i>&nbsp;                break;</b>
<i>1244</i>&nbsp;            case &#39;{&#39;:
<i>1245</i>&nbsp;                // this consumes lobs as well since the double
<i>1246</i>&nbsp;                // braces count correctly and the contents
<i>1247</i>&nbsp;                // of either clobs or blobs will be just content
<b class="fc"><i>1248</i>&nbsp;                c = read_char();</b>
<b class="fc"><i>1249</i>&nbsp;                if (c == &#39;{&#39;) {</b>
<i>1250</i>&nbsp;                    // 2nd &#39;{&#39; - it&#39;s a lob of some sort - let&#39;s find out what sort
<b class="fc"><i>1251</i>&nbsp;                    c = skip_over_lob_whitespace();</b>
<i>1252</i>&nbsp;
<i>1253</i>&nbsp;                    int lobType;
<b class="fc"><i>1254</i>&nbsp;                    if (c == &#39;&quot;&#39;) {</b>
<i>1255</i>&nbsp;                        // clob, double quoted
<b class="fc"><i>1256</i>&nbsp;                        lobType = IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE;</b>
<i>1257</i>&nbsp;                    }
<b class="fc"><i>1258</i>&nbsp;                    else if (c == &#39;\&#39;&#39;) {</b>
<i>1259</i>&nbsp;                        // clob, triple quoted - or error
<b class="fc"><i>1260</i>&nbsp;                        if (!is_2_single_quotes_helper()) {</b>
<b class="nc"><i>1261</i>&nbsp;                            error(&quot;invalid single quote in lob content&quot;);</b>
<i>1262</i>&nbsp;                        }
<b class="fc"><i>1263</i>&nbsp;                        lobType = IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE;</b>
<i>1264</i>&nbsp;                    }
<i>1265</i>&nbsp;                    else {
<i>1266</i>&nbsp;                        // blob
<b class="fc"><i>1267</i>&nbsp;                        unread_char(c);</b>
<b class="fc"><i>1268</i>&nbsp;                        lobType = IonTokenConstsX.TOKEN_OPEN_DOUBLE_BRACE;</b>
<i>1269</i>&nbsp;                    }
<i>1270</i>&nbsp;
<b class="fc"><i>1271</i>&nbsp;                    skip_over_lob(lobType, null);</b>
<b class="fc"><i>1272</i>&nbsp;                }</b>
<b class="fc"><i>1273</i>&nbsp;                else if (c == &#39;}&#39;) {</b>
<i>1274</i>&nbsp;                    // do nothing, we just opened and closed an empty struct
<i>1275</i>&nbsp;                    // move on, there&#39;s nothing to see here ...
<i>1276</i>&nbsp;                }
<i>1277</i>&nbsp;                else {
<b class="fc"><i>1278</i>&nbsp;                    unread_char(c);</b>
<b class="fc"><i>1279</i>&nbsp;                    skip_over_container(&#39;}&#39;);</b>
<i>1280</i>&nbsp;                }
<b class="fc"><i>1281</i>&nbsp;                break;</b>
<i>1282</i>&nbsp;            default:
<b class="fc"><i>1283</i>&nbsp;                break;</b>
<i>1284</i>&nbsp;            }
<i>1285</i>&nbsp;        }
<i>1286</i>&nbsp;    }
<i>1287</i>&nbsp;
<i>1288</i>&nbsp;    private int skip_over_number(SavePoint sp) throws IOException
<i>1289</i>&nbsp;    {
<b class="fc"><i>1290</i>&nbsp;        int c = read_char();</b>
<i>1291</i>&nbsp;
<i>1292</i>&nbsp;        // first consume any leading 0 to get it out of the way
<b class="fc"><i>1293</i>&nbsp;        if (c == &#39;-&#39;) {</b>
<b class="fc"><i>1294</i>&nbsp;            c = read_char();</b>
<i>1295</i>&nbsp;        }
<i>1296</i>&nbsp;        // could be a long int, a decimal, a float
<i>1297</i>&nbsp;        // it cannot be a hex or a valid timestamp
<i>1298</i>&nbsp;        // so scan digits - if decimal can more digits
<i>1299</i>&nbsp;        // if d or e eat possible sign
<i>1300</i>&nbsp;        // scan to end of digits
<b class="fc"><i>1301</i>&nbsp;        c = skip_over_digits(c);</b>
<b class="fc"><i>1302</i>&nbsp;        if (c == &#39;.&#39;) {</b>
<b class="nc"><i>1303</i>&nbsp;            c = read_char();</b>
<b class="nc"><i>1304</i>&nbsp;            c = skip_over_digits(c);</b>
<i>1305</i>&nbsp;        }
<b class="fc"><i>1306</i>&nbsp;        if (c == &#39;d&#39; || c == &#39;D&#39; || c == &#39;e&#39; || c == &#39;E&#39;) {</b>
<b class="fc"><i>1307</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>1308</i>&nbsp;            if (c == &#39;-&#39; || c == &#39;+&#39;) {</b>
<b class="fc"><i>1309</i>&nbsp;                c = read_char();</b>
<i>1310</i>&nbsp;            }
<b class="fc"><i>1311</i>&nbsp;            c = skip_over_digits(c);</b>
<i>1312</i>&nbsp;        }
<b class="fc"><i>1313</i>&nbsp;        if (!is_value_terminating_character(c)) {</b>
<b class="nc"><i>1314</i>&nbsp;            bad_token(c);</b>
<i>1315</i>&nbsp;        }
<b class="fc"><i>1316</i>&nbsp;        if (sp != null) {</b>
<b class="nc"><i>1317</i>&nbsp;            sp.markEnd(-1);</b>
<i>1318</i>&nbsp;        }
<b class="fc"><i>1319</i>&nbsp;        return c;</b>
<i>1320</i>&nbsp;    }
<i>1321</i>&nbsp;    private int skip_over_int(SavePoint sp) throws IOException
<i>1322</i>&nbsp;    {
<b class="fc"><i>1323</i>&nbsp;        int c = read_char();</b>
<b class="fc"><i>1324</i>&nbsp;        if (c == &#39;-&#39;) {</b>
<b class="fc"><i>1325</i>&nbsp;            c = read_char();</b>
<i>1326</i>&nbsp;        }
<b class="fc"><i>1327</i>&nbsp;        c = skip_over_digits(c);</b>
<b class="fc"><i>1328</i>&nbsp;        if (!is_value_terminating_character(c)) {</b>
<b class="nc"><i>1329</i>&nbsp;            bad_token(c);</b>
<i>1330</i>&nbsp;        }
<b class="fc"><i>1331</i>&nbsp;        if (sp != null) {</b>
<b class="nc"><i>1332</i>&nbsp;            sp.markEnd(-1);</b>
<i>1333</i>&nbsp;        }
<b class="fc"><i>1334</i>&nbsp;        return c;</b>
<i>1335</i>&nbsp;    }
<i>1336</i>&nbsp;    private int skip_over_digits(int c) throws IOException
<i>1337</i>&nbsp;    {
<b class="fc"><i>1338</i>&nbsp;        while (IonTokenConstsX.isDigit(c)) {</b>
<b class="fc"><i>1339</i>&nbsp;            c = read_char();</b>
<i>1340</i>&nbsp;        }
<b class="fc"><i>1341</i>&nbsp;        return c;</b>
<i>1342</i>&nbsp;    }
<i>1343</i>&nbsp;
<i>1344</i>&nbsp;    private int skipOverRadix(SavePoint sp, Radix radix) throws IOException
<i>1345</i>&nbsp;    {
<i>1346</i>&nbsp;        int c;
<i>1347</i>&nbsp;
<b class="fc"><i>1348</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>1349</i>&nbsp;        if (c == &#39;-&#39;) {</b>
<b class="fc"><i>1350</i>&nbsp;            c = read_char();</b>
<i>1351</i>&nbsp;        }
<b class="fc"><i>1352</i>&nbsp;        assert(c == &#39;0&#39;);</b>
<b class="fc"><i>1353</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>1354</i>&nbsp;        radix.assertPrefix(c);</b>
<i>1355</i>&nbsp;
<b class="fc"><i>1356</i>&nbsp;        c = readNumeric(NULL_APPENDABLE, radix);</b>
<i>1357</i>&nbsp;
<b class="fc"><i>1358</i>&nbsp;        if (!is_value_terminating_character(c)) {</b>
<b class="nc"><i>1359</i>&nbsp;            bad_token(c);</b>
<i>1360</i>&nbsp;        }
<b class="fc"><i>1361</i>&nbsp;        if (sp != null) {</b>
<b class="nc"><i>1362</i>&nbsp;            sp.markEnd(-1);</b>
<i>1363</i>&nbsp;        }
<i>1364</i>&nbsp;
<b class="fc"><i>1365</i>&nbsp;        return c;</b>
<i>1366</i>&nbsp;    }
<i>1367</i>&nbsp;
<i>1368</i>&nbsp;    private int skip_over_decimal(SavePoint sp) throws IOException
<i>1369</i>&nbsp;    {
<b class="fc"><i>1370</i>&nbsp;        int c = skip_over_number(sp);</b>
<b class="fc"><i>1371</i>&nbsp;        return c;</b>
<i>1372</i>&nbsp;    }
<i>1373</i>&nbsp;    private int skip_over_float(SavePoint sp) throws IOException
<i>1374</i>&nbsp;    {
<b class="fc"><i>1375</i>&nbsp;        int c = skip_over_number(sp);</b>
<b class="fc"><i>1376</i>&nbsp;        return c;</b>
<i>1377</i>&nbsp;    }
<i>1378</i>&nbsp;    private int skip_over_timestamp(SavePoint sp) throws IOException
<i>1379</i>&nbsp;    {
<i>1380</i>&nbsp;        // we know we have dddd- or ddddT we don&#39;t know what follows
<i>1381</i>&nbsp;        // is should be dddd-mm
<b class="fc"><i>1382</i>&nbsp;        int c = skip_timestamp_past_digits(4);</b>
<b class="fc"><i>1383</i>&nbsp;        if (c == &#39;T&#39;) {</b>
<i>1384</i>&nbsp;            // yyyyT
<b class="fc"><i>1385</i>&nbsp;            if (sp != null) {</b>
<b class="nc"><i>1386</i>&nbsp;                sp.markEnd(0);</b>
<i>1387</i>&nbsp;            }
<b class="fc"><i>1388</i>&nbsp;            return skip_over_whitespace(); // prefetch</b>
<i>1389</i>&nbsp;        }
<b class="fc"><i>1390</i>&nbsp;        if (c != &#39;-&#39;) {</b>
<b class="nc"><i>1391</i>&nbsp;            error(&quot;invalid timestamp encountered&quot;);</b>
<i>1392</i>&nbsp;        }
<i>1393</i>&nbsp;        // yyyy-mmT
<i>1394</i>&nbsp;        // yyyy-mm-ddT
<i>1395</i>&nbsp;        // yyyy-mm-ddT+hh:mm
<i>1396</i>&nbsp;        // yyyy-mm-ddThh:mm+hh:mm
<i>1397</i>&nbsp;        // yyyy-mm-ddThh:mm:ss+hh:mm
<i>1398</i>&nbsp;        // yyyy-mm-ddThh:mm:ss.dddd+hh:mm
<i>1399</i>&nbsp;        // yyyy-mm-ddThh:mmZ
<i>1400</i>&nbsp;        // yyyy-mm-ddThh:mm:ssZ
<i>1401</i>&nbsp;        // yyyy-mm-ddThh:mm:ss.ddddZ
<b class="fc"><i>1402</i>&nbsp;        c = skip_timestamp_past_digits(2);</b>
<b class="fc"><i>1403</i>&nbsp;        if (c == &#39;T&#39;) {</b>
<i>1404</i>&nbsp;            // yyyy-mmT
<b class="fc"><i>1405</i>&nbsp;            if (sp != null) {</b>
<b class="nc"><i>1406</i>&nbsp;                sp.markEnd(0);</b>
<i>1407</i>&nbsp;            }
<b class="fc"><i>1408</i>&nbsp;            return skip_over_whitespace(); // prefetch</b>
<i>1409</i>&nbsp;        }
<b class="fc"><i>1410</i>&nbsp;        skip_timestamp_validate(c, &#39;-&#39;);</b>
<b class="fc"><i>1411</i>&nbsp;        c = skip_timestamp_past_digits(2);</b>
<b class="fc"><i>1412</i>&nbsp;        if ( c != &#39;T&#39; ) {</b>
<b class="fc"><i>1413</i>&nbsp;            return skip_timestamp_finish(c, sp);</b>
<i>1414</i>&nbsp;        }
<b class="fc"><i>1415</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>1416</i>&nbsp;        if (!IonTokenConstsX.isDigit(c)) {</b>
<i>1417</i>&nbsp;            // yyyy-mm-ddT
<b class="fc"><i>1418</i>&nbsp;            return skip_timestamp_finish(skip_optional_timestamp_offset(c), sp);</b>
<i>1419</i>&nbsp;        }
<i>1420</i>&nbsp;        // one hour digit already read above
<b class="fc"><i>1421</i>&nbsp;        c = skip_timestamp_past_digits(1);</b>
<b class="fc"><i>1422</i>&nbsp;        if (c != &#39;:&#39;) {</b>
<b class="nc"><i>1423</i>&nbsp;            bad_token(c);</b>
<i>1424</i>&nbsp;        }
<b class="fc"><i>1425</i>&nbsp;        c = skip_timestamp_past_digits(2);</b>
<b class="fc"><i>1426</i>&nbsp;        if (c != &#39;:&#39;) {</b>
<i>1427</i>&nbsp;            // yyyy-mm-ddThh:mm?
<b class="fc"><i>1428</i>&nbsp;            return skip_timestamp_offset_or_z(c, sp);</b>
<i>1429</i>&nbsp;        }
<b class="fc"><i>1430</i>&nbsp;        c = skip_timestamp_past_digits(2);</b>
<b class="fc"><i>1431</i>&nbsp;        if (c != &#39;.&#39;) {</b>
<i>1432</i>&nbsp;            // yyyy-mm-ddThh:mm:ss?
<b class="fc"><i>1433</i>&nbsp;            return skip_timestamp_offset_or_z(c, sp);</b>
<i>1434</i>&nbsp;        }
<b class="fc"><i>1435</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>1436</i>&nbsp;        if (IonTokenConstsX.isDigit(c)) {</b>
<b class="fc"><i>1437</i>&nbsp;            c = skip_over_digits(c);</b>
<i>1438</i>&nbsp;        }
<i>1439</i>&nbsp;        // yyyy-mm-ddThh:mm:ss.ddd?
<i>1440</i>&nbsp;
<b class="fc"><i>1441</i>&nbsp;        return skip_timestamp_offset_or_z(c, sp);</b>
<i>1442</i>&nbsp;    }
<i>1443</i>&nbsp;
<i>1444</i>&nbsp;    private int skip_timestamp_finish(int c, SavePoint sp) throws IOException {
<b class="fc"><i>1445</i>&nbsp;        if (!is_value_terminating_character(c)) {</b>
<b class="nc"><i>1446</i>&nbsp;            bad_token(c);</b>
<i>1447</i>&nbsp;        }
<b class="fc"><i>1448</i>&nbsp;        if (sp != null) {</b>
<b class="nc"><i>1449</i>&nbsp;            sp.markEnd(-1);</b>
<i>1450</i>&nbsp;        }
<b class="fc"><i>1451</i>&nbsp;        return c;</b>
<i>1452</i>&nbsp;    }
<i>1453</i>&nbsp;    private int skip_optional_timestamp_offset(int c) throws IOException
<i>1454</i>&nbsp;    {
<b class="fc"><i>1455</i>&nbsp;        if (c == &#39;-&#39; || c == &#39;+&#39;) {</b>
<b class="nc"><i>1456</i>&nbsp;            c = skip_timestamp_past_digits(2);</b>
<b class="nc"><i>1457</i>&nbsp;            if (c != &#39;:&#39;) {</b>
<b class="nc"><i>1458</i>&nbsp;                bad_token( c );</b>
<i>1459</i>&nbsp;            }
<b class="nc"><i>1460</i>&nbsp;            c = skip_timestamp_past_digits(2);</b>
<i>1461</i>&nbsp;        }
<b class="fc"><i>1462</i>&nbsp;        return c;</b>
<i>1463</i>&nbsp;    }
<i>1464</i>&nbsp;    private int skip_timestamp_offset_or_z(int c, SavePoint sp) throws IOException
<i>1465</i>&nbsp;    {
<b class="fc"><i>1466</i>&nbsp;        if (c == &#39;-&#39; || c == &#39;+&#39;) {</b>
<b class="fc"><i>1467</i>&nbsp;            c = skip_timestamp_past_digits(2);</b>
<b class="fc"><i>1468</i>&nbsp;            if (c != &#39;:&#39;) {</b>
<b class="nc"><i>1469</i>&nbsp;                bad_token( c );</b>
<i>1470</i>&nbsp;            }
<b class="fc"><i>1471</i>&nbsp;            c = skip_timestamp_past_digits(2);</b>
<i>1472</i>&nbsp;        }
<b class="fc"><i>1473</i>&nbsp;        else if (c == &#39;Z&#39; || c == &#39;z&#39;) {</b>
<b class="fc"><i>1474</i>&nbsp;            c = read_char();</b>
<i>1475</i>&nbsp;        } else {
<b class="nc"><i>1476</i>&nbsp;            bad_token(c);</b>
<i>1477</i>&nbsp;        }
<b class="fc"><i>1478</i>&nbsp;        return skip_timestamp_finish(c, sp);</b>
<i>1479</i>&nbsp;    }
<i>1480</i>&nbsp;    private final void skip_timestamp_validate(int c, int expected) {
<b class="fc"><i>1481</i>&nbsp;        if (c != expected) {</b>
<b class="nc"><i>1482</i>&nbsp;            error(&quot;invalid character &#39;&quot;+(char)c+</b>
<i>1483</i>&nbsp;                  &quot;&#39; encountered in timestamp (when &#39;&quot;+(char)expected+
<i>1484</i>&nbsp;                  &quot;&#39; was expected&quot;);
<i>1485</i>&nbsp;        }
<b class="fc"><i>1486</i>&nbsp;    }</b>
<i>1487</i>&nbsp;
<i>1488</i>&nbsp;    /**
<i>1489</i>&nbsp;     * Helper method for skipping embedded digits inside a timestamp value.
<i>1490</i>&nbsp;     * This overload skips exactly the number indicated, and errors if a
<i>1491</i>&nbsp;     * non-digit is encountered.
<i>1492</i>&nbsp;     */
<i>1493</i>&nbsp;    private final int skip_timestamp_past_digits(int len) throws IOException
<i>1494</i>&nbsp;    {
<i>1495</i>&nbsp;        // special case of the other overload
<b class="fc"><i>1496</i>&nbsp;        return skip_timestamp_past_digits(len, len);</b>
<i>1497</i>&nbsp;    }
<i>1498</i>&nbsp;
<i>1499</i>&nbsp;    /**
<i>1500</i>&nbsp;     * Helper method for skipping embedded digits inside a timestamp value
<i>1501</i>&nbsp;     * This overload skips at least min and at most max digits, and errors
<i>1502</i>&nbsp;     * if a non-digit is encountered in the first min characters read
<i>1503</i>&nbsp;     */
<i>1504</i>&nbsp;    private final int skip_timestamp_past_digits(int min, int max)
<i>1505</i>&nbsp;        throws IOException
<i>1506</i>&nbsp;    {
<i>1507</i>&nbsp;        int c;
<i>1508</i>&nbsp;
<i>1509</i>&nbsp;        // scan the first min characters insuring they&#39;re digits
<b class="fc"><i>1510</i>&nbsp;        while (min &gt; 0) {</b>
<b class="fc"><i>1511</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>1512</i>&nbsp;            if (!IonTokenConstsX.isDigit(c)) {</b>
<b class="nc"><i>1513</i>&nbsp;                error(&quot;invalid character &#39;&quot;+(char)c+&quot;&#39; encountered in timestamp&quot;);</b>
<i>1514</i>&nbsp;            }
<b class="fc"><i>1515</i>&nbsp;            --min;</b>
<b class="fc"><i>1516</i>&nbsp;            --max;</b>
<i>1517</i>&nbsp;        }
<i>1518</i>&nbsp;        // stop at the first non digit between min and max
<b class="fc"><i>1519</i>&nbsp;        while (max &gt; 0) {</b>
<b class="nc"><i>1520</i>&nbsp;            c = read_char();</b>
<b class="nc"><i>1521</i>&nbsp;            if (!IonTokenConstsX.isDigit(c)) {</b>
<b class="nc"><i>1522</i>&nbsp;                return c;</b>
<i>1523</i>&nbsp;            }
<b class="nc"><i>1524</i>&nbsp;            --max;</b>
<i>1525</i>&nbsp;        }
<i>1526</i>&nbsp;        // max characters reached; stop
<b class="fc"><i>1527</i>&nbsp;        return read_char();</b>
<i>1528</i>&nbsp;    }
<i>1529</i>&nbsp;    protected IonType load_number(StringBuilder sb) throws IOException
<i>1530</i>&nbsp;    {
<b class="fc"><i>1531</i>&nbsp;        boolean has_sign = false;</b>
<i>1532</i>&nbsp;        int     t, c;
<i>1533</i>&nbsp;
<i>1534</i>&nbsp;        // this reads int, float, decimal and timestamp strings
<i>1535</i>&nbsp;        // anything staring with a +, a - or a digit
<i>1536</i>&nbsp;        //case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
<i>1537</i>&nbsp;        //case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
<i>1538</i>&nbsp;        //case &#39;-&#39;: case &#39;+&#39;:
<i>1539</i>&nbsp;
<i>1540</i>&nbsp;        //start_pos = _stream.getPosition();
<b class="fc"><i>1541</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>1542</i>&nbsp;        has_sign = ((c == &#39;-&#39;) || (c == &#39;+&#39;));</b>
<b class="fc"><i>1543</i>&nbsp;        if (has_sign) {</b>
<i>1544</i>&nbsp;            // if there is a sign character, we just consume it
<i>1545</i>&nbsp;            // here and get whatever is next in line
<b class="fc"><i>1546</i>&nbsp;            sb.append((char)c);</b>
<b class="fc"><i>1547</i>&nbsp;            c = read_char();</b>
<i>1548</i>&nbsp;        }
<i>1549</i>&nbsp;
<i>1550</i>&nbsp;        // first leading digit - to look for hex and
<i>1551</i>&nbsp;        // to make sure that there is at least 1 digit (or
<i>1552</i>&nbsp;        // this isn&#39;t really a number
<b class="fc"><i>1553</i>&nbsp;        if (!IonTokenConstsX.isDigit(c)) {</b>
<i>1554</i>&nbsp;            // if it&#39;s not a digit, this isn&#39;t a number
<i>1555</i>&nbsp;            // the only non-digit it could have been was a
<i>1556</i>&nbsp;            // sign character, and we&#39;ll have read past that
<i>1557</i>&nbsp;            // by now
<i>1558</i>&nbsp;            // TODO this will be a confusing error message,
<i>1559</i>&nbsp;            // but I can&#39;t figure out when it will be reached.
<b class="nc"><i>1560</i>&nbsp;            bad_token(c);</b>
<i>1561</i>&nbsp;        }
<i>1562</i>&nbsp;
<i>1563</i>&nbsp;        // the first digit is a special case
<b class="fc"><i>1564</i>&nbsp;        boolean starts_with_zero = (c == &#39;0&#39;);</b>
<b class="fc"><i>1565</i>&nbsp;        if (starts_with_zero) {</b>
<i>1566</i>&nbsp;            // if it&#39;s a leading 0 check for a hex value
<b class="fc"><i>1567</i>&nbsp;            int c2 = read_char();</b>
<b class="fc"><i>1568</i>&nbsp;            if (Radix.HEX.isPrefix(c2)) {</b>
<b class="fc"><i>1569</i>&nbsp;                sb.append((char)c);</b>
<b class="fc"><i>1570</i>&nbsp;                c = loadRadixValue(sb, has_sign, c2, Radix.HEX);</b>
<b class="fc"><i>1571</i>&nbsp;                return load_finish_number(sb, c, IonTokenConstsX.TOKEN_HEX);</b>
<b class="fc"><i>1572</i>&nbsp;            } else if (Radix.BINARY.isPrefix(c2)) {</b>
<b class="fc"><i>1573</i>&nbsp;                sb.append((char) c);</b>
<b class="fc"><i>1574</i>&nbsp;                c = loadRadixValue(sb, has_sign, c2, Radix.BINARY);</b>
<b class="fc"><i>1575</i>&nbsp;                return load_finish_number(sb, c, IonTokenConstsX.TOKEN_BINARY);</b>
<i>1576</i>&nbsp;            }
<i>1577</i>&nbsp;            // not a next value, back up and try again
<b class="fc"><i>1578</i>&nbsp;            unread_char(c2);</b>
<i>1579</i>&nbsp;        }
<i>1580</i>&nbsp;
<i>1581</i>&nbsp;        // remaining (after the first, c is the first) leading digits
<b class="fc"><i>1582</i>&nbsp;        c = load_digits(sb, c);</b>
<i>1583</i>&nbsp;
<b class="fc"><i>1584</i>&nbsp;        if (c == &#39;-&#39; || c == &#39;T&#39;) {</b>
<i>1585</i>&nbsp;            // this better be a timestamp and it starts with a 4 digit
<i>1586</i>&nbsp;            // year followed by a dash and no leading sign
<b class="fc"><i>1587</i>&nbsp;            if (has_sign) {</b>
<b class="nc"><i>1588</i>&nbsp;                error(&quot;Numeric value followed by invalid character: &quot;</b>
<i>1589</i>&nbsp;                      + sb + (char)c);
<i>1590</i>&nbsp;            }
<b class="fc"><i>1591</i>&nbsp;            int len = sb.length();</b>
<b class="fc"><i>1592</i>&nbsp;            if (len != 4) {</b>
<b class="fc"><i>1593</i>&nbsp;                error(&quot;Numeric value followed by invalid character: &quot;</b>
<i>1594</i>&nbsp;                      + sb + (char)c);
<i>1595</i>&nbsp;            }
<b class="fc"><i>1596</i>&nbsp;            IonType tt = load_timestamp(sb, c);</b>
<b class="fc"><i>1597</i>&nbsp;            return tt;</b>
<i>1598</i>&nbsp;        }
<i>1599</i>&nbsp;
<b class="fc"><i>1600</i>&nbsp;        if (starts_with_zero) {</b>
<i>1601</i>&nbsp;            // Ion doesn&#39;t allow leading zeros, so make sure our buffer only
<i>1602</i>&nbsp;            // has one character.
<b class="fc"><i>1603</i>&nbsp;            int len = sb.length();</b>
<b class="fc"><i>1604</i>&nbsp;            if (has_sign) {</b>
<b class="fc"><i>1605</i>&nbsp;                len--; // we don&#39;t count the sign</b>
<i>1606</i>&nbsp;            }
<b class="fc"><i>1607</i>&nbsp;            if (len != 1) {</b>
<b class="fc"><i>1608</i>&nbsp;                error(&quot;Invalid leading zero in number: &quot; + sb);</b>
<i>1609</i>&nbsp;            }
<i>1610</i>&nbsp;        }
<i>1611</i>&nbsp;
<b class="fc"><i>1612</i>&nbsp;        if (c == &#39;.&#39;) {</b>
<i>1613</i>&nbsp;            // so if it&#39;s a float of some sort
<i>1614</i>&nbsp;            // mark it as at least a DECIMAL
<i>1615</i>&nbsp;            // and read the &quot;fraction&quot; digits
<b class="fc"><i>1616</i>&nbsp;            sb.append((char)c);</b>
<b class="fc"><i>1617</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>1618</i>&nbsp;            c = load_digits(sb, c);</b>
<b class="fc"><i>1619</i>&nbsp;            t = IonTokenConstsX.TOKEN_DECIMAL;</b>
<i>1620</i>&nbsp;        }
<i>1621</i>&nbsp;        else {
<b class="fc"><i>1622</i>&nbsp;            t = IonTokenConstsX.TOKEN_INT;</b>
<i>1623</i>&nbsp;        }
<i>1624</i>&nbsp;
<i>1625</i>&nbsp;        // see if we have an exponential as in 2d+3
<b class="fc"><i>1626</i>&nbsp;        if (c == &#39;e&#39; || c == &#39;E&#39;) {</b>
<b class="fc"><i>1627</i>&nbsp;            t = IonTokenConstsX.TOKEN_FLOAT;</b>
<b class="fc"><i>1628</i>&nbsp;            sb.append((char)c);</b>
<b class="fc"><i>1629</i>&nbsp;            c = load_exponent(sb);  // the unused lookahead char</b>
<i>1630</i>&nbsp;        }
<b class="fc"><i>1631</i>&nbsp;        else if (c == &#39;d&#39; || c == &#39;D&#39;) {</b>
<b class="fc"><i>1632</i>&nbsp;            t = IonTokenConstsX.TOKEN_DECIMAL;</b>
<b class="fc"><i>1633</i>&nbsp;            sb.append((char)c);</b>
<b class="fc"><i>1634</i>&nbsp;            c = load_exponent(sb);</b>
<i>1635</i>&nbsp;        }
<b class="fc"><i>1636</i>&nbsp;        return load_finish_number(sb, c, t);</b>
<i>1637</i>&nbsp;    }
<i>1638</i>&nbsp;
<i>1639</i>&nbsp;    private final IonType load_finish_number(CharSequence numericText, int c,
<i>1640</i>&nbsp;                                             int token)
<i>1641</i>&nbsp;    throws IOException
<i>1642</i>&nbsp;    {
<i>1643</i>&nbsp;        // all forms of numeric need to stop someplace rational
<b class="fc"><i>1644</i>&nbsp;        if (! is_value_terminating_character(c)) {</b>
<b class="fc"><i>1645</i>&nbsp;            error(&quot;Numeric value followed by invalid character: &quot;</b>
<i>1646</i>&nbsp;                  + numericText + (char)c);
<i>1647</i>&nbsp;        }
<i>1648</i>&nbsp;
<i>1649</i>&nbsp;        // we read off the end of the number, so put back
<i>1650</i>&nbsp;        // what we don&#39;t want, but what ever we have is an int
<b class="fc"><i>1651</i>&nbsp;        unread_char(c);</b>
<b class="fc"><i>1652</i>&nbsp;        IonType it = IonTokenConstsX.ion_type_of_scalar(token);</b>
<b class="fc"><i>1653</i>&nbsp;        return it;</b>
<i>1654</i>&nbsp;    }
<i>1655</i>&nbsp;    // this returns the lookahead character it didn&#39;t use so the caller
<i>1656</i>&nbsp;    // can unread it
<i>1657</i>&nbsp;    private final int load_exponent(StringBuilder sb) throws IOException
<i>1658</i>&nbsp;    {
<b class="fc"><i>1659</i>&nbsp;        int c = read_char();</b>
<b class="fc"><i>1660</i>&nbsp;        if (c == &#39;-&#39; || c == &#39;+&#39;) {</b>
<b class="fc"><i>1661</i>&nbsp;            sb.append((char)c);</b>
<b class="fc"><i>1662</i>&nbsp;            c = read_char();</b>
<i>1663</i>&nbsp;        }
<b class="fc"><i>1664</i>&nbsp;        c = load_digits(sb, c);</b>
<i>1665</i>&nbsp;
<b class="fc"><i>1666</i>&nbsp;        if (c == &#39;.&#39;) {</b>
<b class="fc"><i>1667</i>&nbsp;            sb.append((char)c);</b>
<b class="fc"><i>1668</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>1669</i>&nbsp;            c = load_digits(sb, c);</b>
<i>1670</i>&nbsp;        }
<b class="fc"><i>1671</i>&nbsp;        return c;</b>
<i>1672</i>&nbsp;    }
<i>1673</i>&nbsp;
<i>1674</i>&nbsp;    /**
<i>1675</i>&nbsp;     * Accumulates digits into the buffer, starting with the given character.
<i>1676</i>&nbsp;     *
<i>1677</i>&nbsp;     * @return the first non-digit character on the input. Could be the given
<i>1678</i>&nbsp;     *  character if its not a digit.
<i>1679</i>&nbsp;     *
<i>1680</i>&nbsp;     * @see IonTokenConstsX#isDigit(int)
<i>1681</i>&nbsp;     */
<i>1682</i>&nbsp;    private final int load_digits(StringBuilder sb, int c) throws IOException
<i>1683</i>&nbsp;    {
<b class="fc"><i>1684</i>&nbsp;        if (!IonTokenConstsX.isDigit(c))</b>
<i>1685</i>&nbsp;        {
<b class="fc"><i>1686</i>&nbsp;            return c;</b>
<i>1687</i>&nbsp;        }
<b class="fc"><i>1688</i>&nbsp;        sb.append((char) c);</b>
<i>1689</i>&nbsp;
<b class="fc"><i>1690</i>&nbsp;        return readNumeric(sb, Radix.DECIMAL, NumericState.DIGIT);</b>
<i>1691</i>&nbsp;    }
<i>1692</i>&nbsp;
<i>1693</i>&nbsp;    private final void load_fixed_digits(StringBuilder sb, int len)
<i>1694</i>&nbsp;        throws IOException
<i>1695</i>&nbsp;    {
<i>1696</i>&nbsp;        int c;
<i>1697</i>&nbsp;
<b class="fc"><i>1698</i>&nbsp;        switch (len) {</b>
<i>1699</i>&nbsp;        default:
<b class="nc"><i>1700</i>&nbsp;            while (len &gt; 4) {</b>
<b class="nc"><i>1701</i>&nbsp;                c = read_char();</b>
<b class="nc"><i>1702</i>&nbsp;                if (!IonTokenConstsX.isDigit(c)) bad_token(c);</b>
<b class="nc"><i>1703</i>&nbsp;                sb.append((char)c);</b>
<b class="nc"><i>1704</i>&nbsp;                len--;</b>
<i>1705</i>&nbsp;            }
<i>1706</i>&nbsp;            // fall through
<i>1707</i>&nbsp;        case 4:
<b class="nc"><i>1708</i>&nbsp;            c = read_char();</b>
<b class="nc"><i>1709</i>&nbsp;            if (!IonTokenConstsX.isDigit(c)) bad_token(c);</b>
<b class="nc"><i>1710</i>&nbsp;            sb.append((char)c);</b>
<i>1711</i>&nbsp;            // fall through
<i>1712</i>&nbsp;        case 3:
<b class="nc"><i>1713</i>&nbsp;            c = read_char();</b>
<b class="nc"><i>1714</i>&nbsp;            if (!IonTokenConstsX.isDigit(c)) bad_token(c);</b>
<b class="nc"><i>1715</i>&nbsp;            sb.append((char)c);</b>
<i>1716</i>&nbsp;            // fall through
<i>1717</i>&nbsp;        case 2:
<b class="fc"><i>1718</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>1719</i>&nbsp;            if (!IonTokenConstsX.isDigit(c)) bad_token(c);</b>
<b class="fc"><i>1720</i>&nbsp;            sb.append((char)c);</b>
<i>1721</i>&nbsp;            // fall through
<i>1722</i>&nbsp;        case 1:
<b class="fc"><i>1723</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>1724</i>&nbsp;            if (!IonTokenConstsX.isDigit(c)) bad_token(c);</b>
<b class="fc"><i>1725</i>&nbsp;            sb.append((char)c);</b>
<i>1726</i>&nbsp;            break;
<i>1727</i>&nbsp;        }
<i>1728</i>&nbsp;
<b class="fc"><i>1729</i>&nbsp;        return;</b>
<i>1730</i>&nbsp;    }
<i>1731</i>&nbsp;    private final IonType load_timestamp(StringBuilder sb, int c)
<i>1732</i>&nbsp;        throws IOException
<i>1733</i>&nbsp;    {
<i>1734</i>&nbsp;        // we read the year in our caller, we should only be
<i>1735</i>&nbsp;        // here is we read 4 digits and then a dash or a &#39;T&#39;
<b class="fc"><i>1736</i>&nbsp;        assert (c == &#39;-&#39; || c == &#39;T&#39;);</b>
<i>1737</i>&nbsp;
<b class="fc"><i>1738</i>&nbsp;        sb.append((char)c);</b>
<i>1739</i>&nbsp;
<i>1740</i>&nbsp;        // if it&#39;s &#39;T&#39; we done: yyyyT
<b class="fc"><i>1741</i>&nbsp;        if (c == &#39;T&#39;) {</b>
<b class="fc"><i>1742</i>&nbsp;            c = read_char(); // because we&#39;ll unread it before we return</b>
<b class="fc"><i>1743</i>&nbsp;            return load_finish_number(sb, c, IonTokenConstsX.TOKEN_TIMESTAMP);</b>
<i>1744</i>&nbsp;        }
<i>1745</i>&nbsp;
<i>1746</i>&nbsp;        // read month
<b class="fc"><i>1747</i>&nbsp;        load_fixed_digits(sb, 2);</b>
<i>1748</i>&nbsp;
<b class="fc"><i>1749</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>1750</i>&nbsp;        if (c == &#39;T&#39;) {</b>
<b class="fc"><i>1751</i>&nbsp;            sb.append((char)c);</b>
<b class="fc"><i>1752</i>&nbsp;            c = read_char(); // because we&#39;ll unread it before we return</b>
<b class="fc"><i>1753</i>&nbsp;            return load_finish_number(sb, c, IonTokenConstsX.TOKEN_TIMESTAMP);</b>
<i>1754</i>&nbsp;        }
<b class="fc"><i>1755</i>&nbsp;        if (c != &#39;-&#39;) bad_token(c);</b>
<i>1756</i>&nbsp;
<i>1757</i>&nbsp;        // read day
<b class="fc"><i>1758</i>&nbsp;        sb.append((char)c);</b>
<b class="fc"><i>1759</i>&nbsp;        load_fixed_digits(sb, 2);</b>
<i>1760</i>&nbsp;
<i>1761</i>&nbsp;        // look for the &#39;T&#39;, otherwise we&#39;re done (and happy about it)
<b class="fc"><i>1762</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>1763</i>&nbsp;        if (c != &#39;T&#39;) {</b>
<b class="fc"><i>1764</i>&nbsp;            return load_finish_number(sb, c, IonTokenConstsX.TOKEN_TIMESTAMP);</b>
<i>1765</i>&nbsp;        }
<i>1766</i>&nbsp;
<i>1767</i>&nbsp;        // so either we&#39;re done or we must at least hours and minutes
<i>1768</i>&nbsp;        // hour
<b class="fc"><i>1769</i>&nbsp;        sb.append((char)c);</b>
<b class="fc"><i>1770</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>1771</i>&nbsp;        if (!IonTokenConstsX.isDigit(c)) {</b>
<b class="fc"><i>1772</i>&nbsp;            return load_finish_number(sb, c, IonTokenConstsX.TOKEN_TIMESTAMP);</b>
<i>1773</i>&nbsp;        }
<b class="fc"><i>1774</i>&nbsp;        sb.append((char)c);</b>
<b class="fc"><i>1775</i>&nbsp;        load_fixed_digits(sb,1); // we already read the first digit</b>
<b class="fc"><i>1776</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>1777</i>&nbsp;        if (c != &#39;:&#39;) bad_token(c);</b>
<i>1778</i>&nbsp;
<i>1779</i>&nbsp;        // minutes
<b class="fc"><i>1780</i>&nbsp;        sb.append((char)c);</b>
<b class="fc"><i>1781</i>&nbsp;        load_fixed_digits(sb, 2);</b>
<b class="fc"><i>1782</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>1783</i>&nbsp;        if (c == &#39;:&#39;) {</b>
<i>1784</i>&nbsp;            // seconds are optional
<i>1785</i>&nbsp;            // and first we&#39;ll have the whole seconds
<b class="fc"><i>1786</i>&nbsp;            sb.append((char)c);</b>
<b class="fc"><i>1787</i>&nbsp;            load_fixed_digits(sb, 2);</b>
<b class="fc"><i>1788</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>1789</i>&nbsp;            if (c == &#39;.&#39;) {</b>
<b class="fc"><i>1790</i>&nbsp;                sb.append((char)c);</b>
<b class="fc"><i>1791</i>&nbsp;                c = read_char();</b>
<i>1792</i>&nbsp;                // Per spec and W3C Note http://www.w3.org/TR/NOTE-datetime
<i>1793</i>&nbsp;                // We require at least one digit after the decimal point.
<b class="fc"><i>1794</i>&nbsp;                if (!IonTokenConstsX.isDigit(c)) {</b>
<b class="fc"><i>1795</i>&nbsp;                    expected_but_found(&quot;at least one digit after timestamp&#39;s decimal point&quot;, c);</b>
<i>1796</i>&nbsp;                }
<b class="fc"><i>1797</i>&nbsp;                c = load_digits(sb,c);</b>
<i>1798</i>&nbsp;            }
<i>1799</i>&nbsp;        }
<i>1800</i>&nbsp;
<i>1801</i>&nbsp;        // since we have a time, we have to have a timezone of some sort
<i>1802</i>&nbsp;        // the timezone offset starts with a &#39;+&#39; &#39;-&#39; &#39;Z&#39; or &#39;z&#39;
<b class="fc"><i>1803</i>&nbsp;        if (c == &#39;z&#39; || c == &#39;Z&#39;) {</b>
<b class="fc"><i>1804</i>&nbsp;            sb.append((char)c);</b>
<i>1805</i>&nbsp;            // read ahead since we&#39;ll check for a valid ending in a bit
<b class="fc"><i>1806</i>&nbsp;            c = read_char();</b>
<i>1807</i>&nbsp;        }
<b class="fc"><i>1808</i>&nbsp;        else if (c == &#39;+&#39; || c == &#39;-&#39;) {</b>
<i>1809</i>&nbsp;            // then ... hours of time offset
<b class="fc"><i>1810</i>&nbsp;            sb.append((char)c);</b>
<b class="fc"><i>1811</i>&nbsp;            load_fixed_digits(sb, 2);</b>
<b class="fc"><i>1812</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>1813</i>&nbsp;            if (c != &#39;:&#39;) {</b>
<i>1814</i>&nbsp;                // those hours need their minutes if it wasn&#39;t a &#39;z&#39;
<i>1815</i>&nbsp;                // (above) then it has to be a +/- hours { : minutes }
<b class="fc"><i>1816</i>&nbsp;                bad_token(c);</b>
<i>1817</i>&nbsp;            }
<i>1818</i>&nbsp;            // and finally the *not* optional minutes of time offset
<b class="fc"><i>1819</i>&nbsp;            sb.append((char)c);</b>
<b class="fc"><i>1820</i>&nbsp;            load_fixed_digits(sb, 2);</b>
<b class="fc"><i>1821</i>&nbsp;            c = read_char();</b>
<i>1822</i>&nbsp;        }
<i>1823</i>&nbsp;        else {
<i>1824</i>&nbsp;            // some sort of offset is required with a time value
<i>1825</i>&nbsp;            // if it wasn&#39;t a &#39;z&#39; (above) then it has to be a +/- hours { : minutes }
<b class="fc"><i>1826</i>&nbsp;            bad_token(c);</b>
<i>1827</i>&nbsp;        }
<b class="fc"><i>1828</i>&nbsp;        return load_finish_number(sb, c, IonTokenConstsX.TOKEN_TIMESTAMP);</b>
<i>1829</i>&nbsp;    }
<i>1830</i>&nbsp;
<i>1831</i>&nbsp;    private final int loadRadixValue(StringBuilder sb, boolean has_sign, int c2, Radix radix)
<i>1832</i>&nbsp;        throws IOException
<i>1833</i>&nbsp;    {
<b class="fc"><i>1834</i>&nbsp;        radix.assertPrefix(c2);</b>
<b class="fc"><i>1835</i>&nbsp;        sb.append((char) c2);</b>
<i>1836</i>&nbsp;
<b class="fc"><i>1837</i>&nbsp;        return readNumeric(sb, radix);</b>
<i>1838</i>&nbsp;    }
<i>1839</i>&nbsp;
<i>1840</i>&nbsp;    private final int skip_over_symbol_identifier(SavePoint sp) throws IOException
<i>1841</i>&nbsp;    {
<b class="fc"><i>1842</i>&nbsp;        int c = read_char();</b>
<i>1843</i>&nbsp;
<b class="fc"><i>1844</i>&nbsp;        while(IonTokenConstsX.isValidSymbolCharacter(c)) {</b>
<b class="fc"><i>1845</i>&nbsp;            c = read_char();</b>
<i>1846</i>&nbsp;        }
<i>1847</i>&nbsp;
<b class="fc"><i>1848</i>&nbsp;        if (sp != null) {</b>
<b class="fc"><i>1849</i>&nbsp;            sp.markEnd(0);</b>
<i>1850</i>&nbsp;         }
<b class="fc"><i>1851</i>&nbsp;        return c;</b>
<i>1852</i>&nbsp;    }
<i>1853</i>&nbsp;
<i>1854</i>&nbsp;    protected void load_symbol_identifier(StringBuilder sb) throws IOException
<i>1855</i>&nbsp;    {
<b class="fc"><i>1856</i>&nbsp;        int c = read_char();</b>
<b class="fc"><i>1857</i>&nbsp;        while(IonTokenConstsX.isValidSymbolCharacter(c)) {</b>
<b class="fc"><i>1858</i>&nbsp;            sb.append((char)c);</b>
<b class="fc"><i>1859</i>&nbsp;            c = read_char();</b>
<i>1860</i>&nbsp;        }
<b class="fc"><i>1861</i>&nbsp;        unread_char(c);</b>
<b class="fc"><i>1862</i>&nbsp;    }</b>
<i>1863</i>&nbsp;
<i>1864</i>&nbsp;    private int skip_over_symbol_operator(SavePoint sp) throws IOException
<i>1865</i>&nbsp;    {
<b class="fc"><i>1866</i>&nbsp;        int c = read_char();</b>
<i>1867</i>&nbsp;
<i>1868</i>&nbsp;        // lookahead for +inf and -inf
<b class="fc"><i>1869</i>&nbsp;        if (peek_inf_helper(c)) // this will consume the inf if it succeeds</b>
<i>1870</i>&nbsp;        {
<i>1871</i>&nbsp;            // do nothing, peek_inf did all the work for us
<i>1872</i>&nbsp;            // (such as it is)
<b class="nc"><i>1873</i>&nbsp;            c = read_char();</b>
<i>1874</i>&nbsp;        }
<i>1875</i>&nbsp;        else {
<b class="fc"><i>1876</i>&nbsp;            assert(IonTokenConstsX.isValidExtendedSymbolCharacter(c));</b>
<i>1877</i>&nbsp;
<i>1878</i>&nbsp;            // if it&#39;s not +/- inf then we&#39;ll just read the characters normally
<b class="fc"><i>1879</i>&nbsp;            while (IonTokenConstsX.isValidExtendedSymbolCharacter(c)) {</b>
<b class="fc"><i>1880</i>&nbsp;                c = read_char();</b>
<i>1881</i>&nbsp;            }
<i>1882</i>&nbsp;        }
<b class="fc"><i>1883</i>&nbsp;        if (sp != null) {</b>
<b class="nc"><i>1884</i>&nbsp;            sp.markEnd(0);</b>
<i>1885</i>&nbsp;        }
<b class="fc"><i>1886</i>&nbsp;        return c;</b>
<i>1887</i>&nbsp;    }
<i>1888</i>&nbsp;    protected void load_symbol_operator(StringBuilder sb) throws IOException
<i>1889</i>&nbsp;    {
<b class="fc"><i>1890</i>&nbsp;        int c = read_char();</b>
<i>1891</i>&nbsp;
<i>1892</i>&nbsp;        // lookahead for +inf and -inf
<i>1893</i>&nbsp;        // this will consume the inf if it succeeds
<b class="fc"><i>1894</i>&nbsp;        if ((c == &#39;+&#39; || c == &#39;-&#39;) &amp;&amp; peek_inf_helper(c)) {</b>
<b class="nc"><i>1895</i>&nbsp;            sb.append((char)c);</b>
<b class="nc"><i>1896</i>&nbsp;            sb.append(&quot;inf&quot;);</b>
<i>1897</i>&nbsp;        }
<i>1898</i>&nbsp;        else {
<b class="fc"><i>1899</i>&nbsp;            assert(IonTokenConstsX.isValidExtendedSymbolCharacter(c));</b>
<i>1900</i>&nbsp;
<i>1901</i>&nbsp;            // if it&#39;s not +/- inf then we&#39;ll just read the characters normally
<b class="fc"><i>1902</i>&nbsp;            while (IonTokenConstsX.isValidExtendedSymbolCharacter(c)) {</b>
<b class="fc"><i>1903</i>&nbsp;                sb.append((char)c);</b>
<b class="fc"><i>1904</i>&nbsp;                c = read_char();</b>
<i>1905</i>&nbsp;            }
<b class="fc"><i>1906</i>&nbsp;            unread_char(c);</b>
<i>1907</i>&nbsp;        }
<i>1908</i>&nbsp;
<b class="fc"><i>1909</i>&nbsp;        return;</b>
<i>1910</i>&nbsp;    }
<i>1911</i>&nbsp;    private final int skip_single_quoted_string(SavePoint sp) throws IOException
<i>1912</i>&nbsp;    {
<i>1913</i>&nbsp;        int c;
<i>1914</i>&nbsp;
<i>1915</i>&nbsp;        // the position should always be correct here
<i>1916</i>&nbsp;        // since there&#39;s no reason to lookahead into a
<i>1917</i>&nbsp;        // quoted symbol
<i>1918</i>&nbsp;
<i>1919</i>&nbsp;        for (;;) {
<b class="fc"><i>1920</i>&nbsp;            c = read_string_char(ProhibitedCharacters.NONE);</b>
<b class="fc"><i>1921</i>&nbsp;            switch (c) {</b>
<b class="nc"><i>1922</i>&nbsp;            case -1: unexpected_eof();</b>
<i>1923</i>&nbsp;            case &#39;\&#39;&#39;:
<b class="fc"><i>1924</i>&nbsp;                if (sp != null) {</b>
<b class="fc"><i>1925</i>&nbsp;                   sp.markEnd(-1);</b>
<i>1926</i>&nbsp;                }
<b class="fc"><i>1927</i>&nbsp;                return read_char(); // Return the next character beyond the token</b>
<i>1928</i>&nbsp;            case &#39;\\&#39;:
<b class="fc"><i>1929</i>&nbsp;                c = read_char();</b>
<b class="fc"><i>1930</i>&nbsp;                break;</b>
<i>1931</i>&nbsp;            }
<i>1932</i>&nbsp;        }
<i>1933</i>&nbsp;    }
<i>1934</i>&nbsp;
<i>1935</i>&nbsp;    protected int load_single_quoted_string(StringBuilder sb, boolean is_clob)
<i>1936</i>&nbsp;        throws IOException
<i>1937</i>&nbsp;    {
<i>1938</i>&nbsp;        int c;
<b class="fc"><i>1939</i>&nbsp;        boolean expectLowSurrogate = false;</b>
<i>1940</i>&nbsp;
<i>1941</i>&nbsp;        for (;;) {
<b class="fc"><i>1942</i>&nbsp;            c = read_string_char(ProhibitedCharacters.NONE);</b>
<b class="fc"><i>1943</i>&nbsp;            switch (c) {</b>
<i>1944</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
<i>1945</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
<i>1946</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
<b class="fc"><i>1947</i>&nbsp;                continue;</b>
<i>1948</i>&nbsp;            case -1:
<i>1949</i>&nbsp;            case &#39;\&#39;&#39;:
<b class="fc"><i>1950</i>&nbsp;                if (!is_clob) {</b>
<b class="fc"><i>1951</i>&nbsp;                    check_for_low_surrogate(c, expectLowSurrogate);</b>
<i>1952</i>&nbsp;                }
<b class="fc"><i>1953</i>&nbsp;                return c;</b>
<i>1954</i>&nbsp;            // new line normalization and counting is handled in read_char
<i>1955</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
<i>1956</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
<i>1957</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
<b class="nc"><i>1958</i>&nbsp;                bad_token(c);</b>
<i>1959</i>&nbsp;            case &#39;\\&#39;:
<i>1960</i>&nbsp;                // TODO why not read_char_escaped() ?
<i>1961</i>&nbsp;                //  That&#39;s how load_double_quoted_string works.
<b class="fc"><i>1962</i>&nbsp;                c = read_char();</b>
<b class="fc"><i>1963</i>&nbsp;                c = read_escaped_char_content_helper(c, is_clob);</b>
<b class="fc"><i>1964</i>&nbsp;                break;</b>
<i>1965</i>&nbsp;            default:
<b class="fc"><i>1966</i>&nbsp;                if (!is_clob &amp;&amp; !IonTokenConstsX.is7bitValue(c)) {</b>
<b class="fc"><i>1967</i>&nbsp;                    c = read_large_char_sequence(c);</b>
<i>1968</i>&nbsp;                }
<i>1969</i>&nbsp;            }
<i>1970</i>&nbsp;            // if this isn&#39;t a clob we need to decode UTF8 and
<i>1971</i>&nbsp;            // handle surrogate encoding (otherwise we don&#39;t care)
<b class="fc"><i>1972</i>&nbsp;            if (!is_clob) {</b>
<b class="fc"><i>1973</i>&nbsp;                expectLowSurrogate = check_for_low_surrogate(c, expectLowSurrogate);</b>
<i>1974</i>&nbsp;
<b class="fc"><i>1975</i>&nbsp;                if (IonUTF8.needsSurrogateEncoding(c)) {</b>
<b class="fc"><i>1976</i>&nbsp;                    sb.append(IonUTF8.highSurrogate(c));</b>
<b class="fc"><i>1977</i>&nbsp;                    c = IonUTF8.lowSurrogate(c);</b>
<i>1978</i>&nbsp;                } else {
<b class="fc"><i>1979</i>&nbsp;                    expectLowSurrogate = IonUTF8.isHighSurrogate(c);</b>
<i>1980</i>&nbsp;                }
<i>1981</i>&nbsp;            }
<b class="nc"><i>1982</i>&nbsp;            else if (IonTokenConstsX.is8bitValue(c)) {</b>
<b class="nc"><i>1983</i>&nbsp;                bad_token(c);</b>
<i>1984</i>&nbsp;            }
<b class="fc"><i>1985</i>&nbsp;            sb.append((char)c);</b>
<i>1986</i>&nbsp;        }
<i>1987</i>&nbsp;    }
<i>1988</i>&nbsp;
<i>1989</i>&nbsp;    private void skip_double_quoted_string(SavePoint sp) throws IOException
<i>1990</i>&nbsp;    {
<b class="fc"><i>1991</i>&nbsp;        skip_double_quoted_string_helper();</b>
<b class="fc"><i>1992</i>&nbsp;        if (sp != null) {</b>
<b class="fc"><i>1993</i>&nbsp;            sp.markEnd(-1);</b>
<i>1994</i>&nbsp;        }
<b class="fc"><i>1995</i>&nbsp;    }</b>
<i>1996</i>&nbsp;
<i>1997</i>&nbsp;    private final void skip_double_quoted_string_helper() throws IOException
<i>1998</i>&nbsp;    {
<i>1999</i>&nbsp;        int c;
<i>2000</i>&nbsp;        for (;;) {
<b class="fc"><i>2001</i>&nbsp;            c = read_string_char(ProhibitedCharacters.NONE);</b>
<b class="fc"><i>2002</i>&nbsp;            switch (c) {</b>
<i>2003</i>&nbsp;            case -1:
<b class="nc"><i>2004</i>&nbsp;                unexpected_eof(); // throws</b>
<i>2005</i>&nbsp;            // new line normalization and counting is handled in read_char
<i>2006</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
<i>2007</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
<i>2008</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
<b class="fc"><i>2009</i>&nbsp;                bad_token(c); // throws</b>
<i>2010</i>&nbsp;            case &#39;&quot;&#39;:
<b class="fc"><i>2011</i>&nbsp;                return;</b>
<i>2012</i>&nbsp;            case &#39;\\&#39;:
<b class="fc"><i>2013</i>&nbsp;                c = read_char();</b>
<b class="fc"><i>2014</i>&nbsp;                break;</b>
<i>2015</i>&nbsp;            }
<i>2016</i>&nbsp;        }
<i>2017</i>&nbsp;    }
<i>2018</i>&nbsp;
<i>2019</i>&nbsp;    protected int load_double_quoted_string(StringBuilder sb, boolean is_clob)
<i>2020</i>&nbsp;        throws IOException
<i>2021</i>&nbsp;    {
<i>2022</i>&nbsp;        int c;
<b class="fc"><i>2023</i>&nbsp;        boolean expectLowSurrogate = false;</b>
<i>2024</i>&nbsp;
<i>2025</i>&nbsp;        for (;;) {
<b class="fc"><i>2026</i>&nbsp;            c = read_string_char(ProhibitedCharacters.SHORT_CHAR);</b>
<b class="fc"><i>2027</i>&nbsp;            switch (c) {</b>
<i>2028</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
<i>2029</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
<i>2030</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
<b class="fc"><i>2031</i>&nbsp;                continue;</b>
<i>2032</i>&nbsp;            case -1:
<i>2033</i>&nbsp;            case &#39;&quot;&#39;:
<b class="fc"><i>2034</i>&nbsp;                if (!is_clob) {</b>
<b class="fc"><i>2035</i>&nbsp;                    check_for_low_surrogate(c, expectLowSurrogate);</b>
<i>2036</i>&nbsp;                }
<b class="fc"><i>2037</i>&nbsp;                return c;</b>
<i>2038</i>&nbsp;            // new line normalization and counting is handled in read_char
<i>2039</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
<i>2040</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
<i>2041</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
<b class="nc"><i>2042</i>&nbsp;                bad_token(c);</b>
<i>2043</i>&nbsp;            case &#39;\\&#39;:
<b class="fc"><i>2044</i>&nbsp;                c = read_char_escaped(c, is_clob);</b>
<b class="fc"><i>2045</i>&nbsp;                break;</b>
<i>2046</i>&nbsp;            default:
<b class="fc"><i>2047</i>&nbsp;                if (!is_clob &amp;&amp; !IonTokenConstsX.is7bitValue(c)) {</b>
<b class="fc"><i>2048</i>&nbsp;                    c = read_large_char_sequence(c);</b>
<i>2049</i>&nbsp;                }
<i>2050</i>&nbsp;                break;
<i>2051</i>&nbsp;            }
<i>2052</i>&nbsp;            // if this isn&#39;t a clob we need to decode UTF8 and
<i>2053</i>&nbsp;            // handle surrogate encoding (otherwise we don&#39;t care)
<b class="fc"><i>2054</i>&nbsp;            if (!is_clob) {</b>
<b class="fc"><i>2055</i>&nbsp;                expectLowSurrogate = check_for_low_surrogate(c, expectLowSurrogate);</b>
<i>2056</i>&nbsp;
<b class="fc"><i>2057</i>&nbsp;                if (IonUTF8.needsSurrogateEncoding(c)) {</b>
<b class="fc"><i>2058</i>&nbsp;                    sb.append(IonUTF8.highSurrogate(c));</b>
<b class="fc"><i>2059</i>&nbsp;                    c = IonUTF8.lowSurrogate(c);</b>
<i>2060</i>&nbsp;                } else {
<b class="fc"><i>2061</i>&nbsp;                    expectLowSurrogate = IonUTF8.isHighSurrogate(c);</b>
<i>2062</i>&nbsp;                }
<i>2063</i>&nbsp;            }
<b class="fc"><i>2064</i>&nbsp;            sb.append((char)c);</b>
<i>2065</i>&nbsp;        }
<i>2066</i>&nbsp;    }
<i>2067</i>&nbsp;
<i>2068</i>&nbsp;    private boolean check_for_low_surrogate(int c, boolean expectLowSurrogate) throws IonException
<i>2069</i>&nbsp;    {
<b class="fc"><i>2070</i>&nbsp;        if (IonUTF8.isLowSurrogate(c)) {</b>
<b class="fc"><i>2071</i>&nbsp;            if (expectLowSurrogate) {</b>
<b class="fc"><i>2072</i>&nbsp;                return false;</b>
<i>2073</i>&nbsp;            } else {
<b class="fc"><i>2074</i>&nbsp;                error(&quot;unexpected low surrogate &quot; + printCodePointAsString(c));</b>
<i>2075</i>&nbsp;            }
<b class="fc"><i>2076</i>&nbsp;        } else if (expectLowSurrogate) {</b>
<b class="fc"><i>2077</i>&nbsp;            expected_but_found(&quot;a low surrogate&quot;, c);</b>
<i>2078</i>&nbsp;        }
<b class="fc"><i>2079</i>&nbsp;        return false;</b>
<i>2080</i>&nbsp;    }
<i>2081</i>&nbsp;
<i>2082</i>&nbsp;    protected int read_double_quoted_char(boolean is_clob) throws IOException
<i>2083</i>&nbsp;    {
<b class="fc"><i>2084</i>&nbsp;        int c = read_char();</b>
<b class="fc"><i>2085</i>&nbsp;        if(is_clob &amp;&amp; c &gt; 127) {</b>
<b class="fc"><i>2086</i>&nbsp;            throw new IonReaderTextTokenException(&quot;non ASCII character in clob: &quot; + c);</b>
<i>2087</i>&nbsp;        }
<i>2088</i>&nbsp;
<b class="fc"><i>2089</i>&nbsp;        switch (c) {</b>
<i>2090</i>&nbsp;        case &#39;&quot;&#39;:
<b class="nc"><i>2091</i>&nbsp;            unread_char(c);</b>
<b class="nc"><i>2092</i>&nbsp;            c = CharacterSequence.CHAR_SEQ_STRING_TERMINATOR;</b>
<b class="nc"><i>2093</i>&nbsp;            break;</b>
<i>2094</i>&nbsp;        case -1:
<b class="fc"><i>2095</i>&nbsp;            break;</b>
<i>2096</i>&nbsp;        case &#39;\\&#39;:
<b class="fc"><i>2097</i>&nbsp;            c = read_char_escaped(c, is_clob);</b>
<b class="fc"><i>2098</i>&nbsp;            break;</b>
<i>2099</i>&nbsp;        default:
<b class="fc"><i>2100</i>&nbsp;            if (!is_clob &amp;&amp; !IonTokenConstsX.is7bitValue(c)) {</b>
<b class="nc"><i>2101</i>&nbsp;                c = read_large_char_sequence(c);</b>
<i>2102</i>&nbsp;            }
<i>2103</i>&nbsp;            break;
<i>2104</i>&nbsp;        }
<i>2105</i>&nbsp;
<b class="fc"><i>2106</i>&nbsp;        return c;</b>
<i>2107</i>&nbsp;    }
<i>2108</i>&nbsp;
<i>2109</i>&nbsp;    /**
<i>2110</i>&nbsp;     * Skip to the end of a triple quoted string sequence, ignoring any
<i>2111</i>&nbsp;     * comments encountered between triple quoted string elements.
<i>2112</i>&nbsp;     * @param sp
<i>2113</i>&nbsp;     * @throws IOException
<i>2114</i>&nbsp;     */
<i>2115</i>&nbsp;    private void skip_triple_quoted_string(SavePoint sp) throws IOException
<i>2116</i>&nbsp;    {
<b class="fc"><i>2117</i>&nbsp;        skip_triple_quoted_string(sp, CommentStrategy.IGNORE);</b>
<b class="fc"><i>2118</i>&nbsp;    }</b>
<i>2119</i>&nbsp;
<i>2120</i>&nbsp;    /**
<i>2121</i>&nbsp;     * Skip to the end of a triple quoted string sequence within a clob,
<i>2122</i>&nbsp;     * erroring on any comments encountered between triple quoted string
<i>2123</i>&nbsp;     * elements.
<i>2124</i>&nbsp;     * @param sp
<i>2125</i>&nbsp;     * @throws IOException
<i>2126</i>&nbsp;     */
<i>2127</i>&nbsp;    private void skip_triple_quoted_clob_string(SavePoint sp) throws IOException
<i>2128</i>&nbsp;    {
<b class="fc"><i>2129</i>&nbsp;        skip_triple_quoted_string(sp, CommentStrategy.ERROR);</b>
<b class="fc"><i>2130</i>&nbsp;    }</b>
<i>2131</i>&nbsp;
<i>2132</i>&nbsp;    private void skip_triple_quoted_string(SavePoint sp, CommentStrategy commentStrategy) throws IOException
<i>2133</i>&nbsp;    {
<i>2134</i>&nbsp;        // starts AFTER the 3 quotes have been consumed
<i>2135</i>&nbsp;        int c;
<i>2136</i>&nbsp;        for (;;) {
<b class="fc"><i>2137</i>&nbsp;            c = read_char();</b>
<b class="fc"><i>2138</i>&nbsp;            switch (c) {</b>
<i>2139</i>&nbsp;            case -1:
<b class="nc"><i>2140</i>&nbsp;                unexpected_eof();</b>
<i>2141</i>&nbsp;            case &#39;\&#39;&#39;:
<b class="fc"><i>2142</i>&nbsp;                c = read_char();</b>
<b class="fc"><i>2143</i>&nbsp;                if (c == &#39;\&#39;&#39;) { // 2nd quote</b>
<b class="fc"><i>2144</i>&nbsp;                    c = read_char(); // possibly the 3rd</b>
<b class="fc"><i>2145</i>&nbsp;                    if (sp != null) {</b>
<b class="fc"><i>2146</i>&nbsp;                        sp.markEnd(-3);</b>
<i>2147</i>&nbsp;                    }
<b class="fc"><i>2148</i>&nbsp;                    if (c == &#39;\&#39;&#39;) { // it is the 3rd quote - end of this segment</b>
<b class="fc"><i>2149</i>&nbsp;                        c = skip_over_whitespace(commentStrategy);</b>
<b class="fc"><i>2150</i>&nbsp;                        if (c == &#39;\&#39;&#39; &amp;&amp; is_2_single_quotes_helper()) {</b>
<i>2151</i>&nbsp;                            // there&#39;s another segment so read the next segment as well
<b class="fc"><i>2152</i>&nbsp;                            break;</b>
<i>2153</i>&nbsp;                        }
<i>2154</i>&nbsp;                        // end of last segment
<b class="fc"><i>2155</i>&nbsp;                        unread_char(c);</b>
<b class="fc"><i>2156</i>&nbsp;                        return;</b>
<i>2157</i>&nbsp;                    }
<i>2158</i>&nbsp;                }
<i>2159</i>&nbsp;                break;
<i>2160</i>&nbsp;            case &#39;\\&#39;:
<b class="fc"><i>2161</i>&nbsp;                c = read_char();</b>
<b class="fc"><i>2162</i>&nbsp;               break;</b>
<i>2163</i>&nbsp;            }
<i>2164</i>&nbsp;        }
<i>2165</i>&nbsp;    }
<i>2166</i>&nbsp;
<i>2167</i>&nbsp;    protected int load_triple_quoted_string(StringBuilder sb, boolean is_clob)
<i>2168</i>&nbsp;        throws IOException
<i>2169</i>&nbsp;    {
<i>2170</i>&nbsp;        int c;
<b class="fc"><i>2171</i>&nbsp;        boolean expectLowSurrogate = false;</b>
<i>2172</i>&nbsp;
<i>2173</i>&nbsp;        for (;;) {
<b class="fc"><i>2174</i>&nbsp;            c = read_triple_quoted_char(is_clob);</b>
<b class="fc"><i>2175</i>&nbsp;            switch(c) {</b>
<i>2176</i>&nbsp;            case CharacterSequence.CHAR_SEQ_STRING_TERMINATOR:
<i>2177</i>&nbsp;            case CharacterSequence.CHAR_SEQ_EOF: // was EOF
<b class="fc"><i>2178</i>&nbsp;                if (!is_clob) {</b>
<b class="fc"><i>2179</i>&nbsp;                    check_for_low_surrogate(c, expectLowSurrogate);</b>
<i>2180</i>&nbsp;                }
<b class="fc"><i>2181</i>&nbsp;                return c;</b>
<i>2182</i>&nbsp;            // new line normalization and counting is handled in read_char
<i>2183</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
<b class="fc"><i>2184</i>&nbsp;                c = &#39;\n&#39;;</b>
<b class="fc"><i>2185</i>&nbsp;                break;</b>
<i>2186</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
<i>2187</i>&nbsp;                // TODO: uncomment if we don&#39;t want to normalize end of line: c = &#39;\r&#39;;
<b class="fc"><i>2188</i>&nbsp;                c = &#39;\n&#39;;</b>
<b class="fc"><i>2189</i>&nbsp;                break;</b>
<i>2190</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
<i>2191</i>&nbsp;                // TODO: uncomment if we don&#39;t want to normalize end of line: sb.append(&#39;\r&#39;);
<b class="fc"><i>2192</i>&nbsp;                c = &#39;\n&#39;;</b>
<b class="fc"><i>2193</i>&nbsp;                break;</b>
<i>2194</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
<i>2195</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
<i>2196</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
<b class="fc"><i>2197</i>&nbsp;                continue;</b>
<i>2198</i>&nbsp;            case CharacterSequence.CHAR_SEQ_STRING_NON_TERMINATOR:
<b class="fc"><i>2199</i>&nbsp;                if (!is_clob) {</b>
<b class="fc"><i>2200</i>&nbsp;                    expectLowSurrogate = check_for_low_surrogate(c, expectLowSurrogate);</b>
<i>2201</i>&nbsp;                }
<i>2202</i>&nbsp;                continue;
<i>2203</i>&nbsp;            default:
<i>2204</i>&nbsp;                break;
<i>2205</i>&nbsp;            }
<i>2206</i>&nbsp;            // if this isn&#39;t a clob we need to decode UTF8 and
<i>2207</i>&nbsp;            // handle surrogate encoding (otherwise we don&#39;t care)
<b class="fc"><i>2208</i>&nbsp;            if (!is_clob) {</b>
<b class="fc"><i>2209</i>&nbsp;                expectLowSurrogate = check_for_low_surrogate(c, expectLowSurrogate);</b>
<i>2210</i>&nbsp;
<b class="fc"><i>2211</i>&nbsp;                if (IonUTF8.needsSurrogateEncoding(c)) {</b>
<b class="fc"><i>2212</i>&nbsp;                    sb.append(IonUTF8.highSurrogate(c));</b>
<b class="fc"><i>2213</i>&nbsp;                    c = IonUTF8.lowSurrogate(c);</b>
<i>2214</i>&nbsp;                } else {
<b class="fc"><i>2215</i>&nbsp;                    expectLowSurrogate = IonUTF8.isHighSurrogate(c);</b>
<i>2216</i>&nbsp;                }
<i>2217</i>&nbsp;            }
<b class="fc"><i>2218</i>&nbsp;            sb.append((char)c);</b>
<i>2219</i>&nbsp;        }
<i>2220</i>&nbsp;    }
<i>2221</i>&nbsp;
<i>2222</i>&nbsp;    protected int read_triple_quoted_char(boolean is_clob) throws IOException
<i>2223</i>&nbsp;    {
<b class="fc"><i>2224</i>&nbsp;        int c = read_string_char(ProhibitedCharacters.LONG_CHAR);</b>
<b class="fc"><i>2225</i>&nbsp;        if(is_clob &amp;&amp; c &gt; 127) {</b>
<b class="fc"><i>2226</i>&nbsp;            throw new IonReaderTextTokenException(&quot;non ASCII character in clob: &quot; + c);</b>
<i>2227</i>&nbsp;        }
<i>2228</i>&nbsp;
<b class="fc"><i>2229</i>&nbsp;        switch (c) {</b>
<i>2230</i>&nbsp;        case &#39;\&#39;&#39;:
<b class="fc"><i>2231</i>&nbsp;            if (is_2_single_quotes_helper()) {</b>
<i>2232</i>&nbsp;                // so at this point we are at the end of the closing
<i>2233</i>&nbsp;                // triple quote - so we need to look ahead to see if
<i>2234</i>&nbsp;                // there&#39;s just whitespace and a new opening triple quote
<b class="fc"><i>2235</i>&nbsp;                c = skip_over_whitespace();</b>
<b class="fc"><i>2236</i>&nbsp;                if (c == &#39;\&#39;&#39; &amp;&amp; is_2_single_quotes_helper()) {</b>
<i>2237</i>&nbsp;                    // there&#39;s another segment so read the next segment as well
<i>2238</i>&nbsp;                    // since we&#39;re now just before char 1 of the next segment
<i>2239</i>&nbsp;                    // loop again, but don&#39;t append this char
<b class="fc"><i>2240</i>&nbsp;                    return CharacterSequence.CHAR_SEQ_STRING_NON_TERMINATOR;</b>
<i>2241</i>&nbsp;                }
<i>2242</i>&nbsp;                // end of last segment - we&#39;re done (although we read a bit too far)
<b class="fc"><i>2243</i>&nbsp;                unread_char(c);</b>
<b class="fc"><i>2244</i>&nbsp;                c = CharacterSequence.CHAR_SEQ_STRING_TERMINATOR;</b>
<i>2245</i>&nbsp;            }
<i>2246</i>&nbsp;            break;
<i>2247</i>&nbsp;        case &#39;\\&#39;:
<b class="fc"><i>2248</i>&nbsp;            c = read_char_escaped(c, is_clob);</b>
<b class="fc"><i>2249</i>&nbsp;            break;</b>
<i>2250</i>&nbsp;        case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
<i>2251</i>&nbsp;        case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
<i>2252</i>&nbsp;        case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
<i>2253</i>&nbsp;        case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
<i>2254</i>&nbsp;        case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
<i>2255</i>&nbsp;        case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
<b class="fc"><i>2256</i>&nbsp;            break;</b>
<i>2257</i>&nbsp;        case -1:
<b class="fc"><i>2258</i>&nbsp;            break;</b>
<i>2259</i>&nbsp;        default:
<b class="fc"><i>2260</i>&nbsp;            if (!is_clob &amp;&amp; !IonTokenConstsX.is7bitValue(c)) {</b>
<b class="fc"><i>2261</i>&nbsp;                c = read_large_char_sequence(c);</b>
<i>2262</i>&nbsp;            }
<i>2263</i>&nbsp;            break;
<i>2264</i>&nbsp;        }
<i>2265</i>&nbsp;
<b class="fc"><i>2266</i>&nbsp;        return c;</b>
<i>2267</i>&nbsp;    }
<i>2268</i>&nbsp;
<i>2269</i>&nbsp;    /** Skips over the closing }} too. */
<i>2270</i>&nbsp;    protected void skip_over_lob(int lobToken, SavePoint sp) throws IOException {
<b class="fc"><i>2271</i>&nbsp;        switch(lobToken) {</b>
<i>2272</i>&nbsp;        case IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE:
<b class="fc"><i>2273</i>&nbsp;            skip_double_quoted_string(sp);</b>
<b class="fc"><i>2274</i>&nbsp;            skip_clob_close_punctuation();</b>
<b class="fc"><i>2275</i>&nbsp;            break;</b>
<i>2276</i>&nbsp;        case IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE:
<b class="fc"><i>2277</i>&nbsp;            skip_triple_quoted_clob_string(sp);</b>
<b class="fc"><i>2278</i>&nbsp;            skip_clob_close_punctuation();</b>
<b class="fc"><i>2279</i>&nbsp;            break;</b>
<i>2280</i>&nbsp;        case IonTokenConstsX.TOKEN_OPEN_DOUBLE_BRACE:
<b class="fc"><i>2281</i>&nbsp;            skip_over_blob(sp);</b>
<b class="fc"><i>2282</i>&nbsp;            break;</b>
<i>2283</i>&nbsp;        default:
<b class="nc"><i>2284</i>&nbsp;            error(&quot;unexpected token &quot;+IonTokenConstsX.getTokenName(lobToken)+</b>
<i>2285</i>&nbsp;                  &quot; encountered for lob content&quot;);
<i>2286</i>&nbsp;        }
<b class="fc"><i>2287</i>&nbsp;    }</b>
<i>2288</i>&nbsp;
<i>2289</i>&nbsp;    protected void load_clob(int lobToken, StringBuilder sb) throws IOException
<i>2290</i>&nbsp;    {
<b class="nc"><i>2291</i>&nbsp;        switch(lobToken) {</b>
<i>2292</i>&nbsp;        case IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE:
<b class="nc"><i>2293</i>&nbsp;            load_double_quoted_string(sb, true);</b>
<b class="nc"><i>2294</i>&nbsp;            break;</b>
<i>2295</i>&nbsp;        case IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE:
<b class="nc"><i>2296</i>&nbsp;            load_triple_quoted_string(sb, true);</b>
<b class="nc"><i>2297</i>&nbsp;            break;</b>
<i>2298</i>&nbsp;        case IonTokenConstsX.TOKEN_OPEN_DOUBLE_BRACE:
<b class="nc"><i>2299</i>&nbsp;            load_blob(sb);</b>
<b class="nc"><i>2300</i>&nbsp;            break;</b>
<i>2301</i>&nbsp;        default:
<b class="nc"><i>2302</i>&nbsp;            error(&quot;unexpected token &quot;+IonTokenConstsX.getTokenName(lobToken)+</b>
<i>2303</i>&nbsp;                  &quot; encountered for lob content&quot;);
<i>2304</i>&nbsp;        }
<b class="nc"><i>2305</i>&nbsp;    }</b>
<i>2306</i>&nbsp;
<i>2307</i>&nbsp;    private final int read_char_escaped(int c, boolean is_clob)
<i>2308</i>&nbsp;        throws IOException
<i>2309</i>&nbsp;    {
<i>2310</i>&nbsp;        for (;;) {
<b class="fc"><i>2311</i>&nbsp;            switch (c) {</b>
<i>2312</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
<i>2313</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
<i>2314</i>&nbsp;            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
<i>2315</i>&nbsp;                // loop again, we don&#39;t want empty escape chars
<b class="nc"><i>2316</i>&nbsp;                c = read_string_char(ProhibitedCharacters.NONE);</b>
<b class="nc"><i>2317</i>&nbsp;                continue;</b>
<i>2318</i>&nbsp;            case &#39;\\&#39;:
<b class="fc"><i>2319</i>&nbsp;                c = read_char();</b>
<b class="fc"><i>2320</i>&nbsp;                if (c &lt; 0) {</b>
<b class="fc"><i>2321</i>&nbsp;                    unexpected_eof();</b>
<i>2322</i>&nbsp;                }
<b class="fc"><i>2323</i>&nbsp;                c = read_escaped_char_content_helper(c, is_clob);</b>
<b class="fc"><i>2324</i>&nbsp;                if (c == CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1</b>
<i>2325</i>&nbsp;                 || c == CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2
<i>2326</i>&nbsp;                 || c == CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3
<i>2327</i>&nbsp;                ) {
<i>2328</i>&nbsp;                    // loop again, we don&#39;t want empty escape chars
<b class="nc"><i>2329</i>&nbsp;                    c = read_string_char(ProhibitedCharacters.NONE);</b>
<b class="nc"><i>2330</i>&nbsp;                    continue;</b>
<i>2331</i>&nbsp;                }
<b class="fc"><i>2332</i>&nbsp;                if (c == IonTokenConstsX.ESCAPE_NOT_DEFINED) bad_escape_sequence();</b>
<i>2333</i>&nbsp;                break;
<i>2334</i>&nbsp;            default:
<b class="nc"><i>2335</i>&nbsp;                if (!is_clob &amp;&amp; !IonTokenConstsX.is7bitValue(c)) {</b>
<b class="nc"><i>2336</i>&nbsp;                    c = read_large_char_sequence(c);</b>
<i>2337</i>&nbsp;                }
<i>2338</i>&nbsp;                break;
<i>2339</i>&nbsp;            }
<i>2340</i>&nbsp;            break; // at this point we have a post-escaped character to return to the caller
<i>2341</i>&nbsp;        }
<i>2342</i>&nbsp;
<b class="fc"><i>2343</i>&nbsp;        if (c == CharacterSequence.CHAR_SEQ_EOF) return c;</b>
<b class="fc"><i>2344</i>&nbsp;        if (is_clob &amp;&amp; !IonTokenConstsX.is8bitValue(c)) {</b>
<b class="nc"><i>2345</i>&nbsp;            error(&quot;invalid character [&quot;+ printCodePointAsString(c)+&quot;] in CLOB&quot;);</b>
<i>2346</i>&nbsp;        }
<b class="fc"><i>2347</i>&nbsp;        return c;</b>
<i>2348</i>&nbsp;    }
<i>2349</i>&nbsp;
<i>2350</i>&nbsp;    private final int read_large_char_sequence(int c) throws IOException
<i>2351</i>&nbsp;    {
<b class="fc"><i>2352</i>&nbsp;        if (_stream._is_byte_data) {</b>
<b class="fc"><i>2353</i>&nbsp;            return read_ut8_sequence(c);</b>
<i>2354</i>&nbsp;        }
<b class="fc"><i>2355</i>&nbsp;        if (_Private_IonConstants.isHighSurrogate(c)) {</b>
<b class="fc"><i>2356</i>&nbsp;            int c2 = read_char();</b>
<b class="fc"><i>2357</i>&nbsp;            if (_Private_IonConstants.isLowSurrogate(c2)) {</b>
<b class="fc"><i>2358</i>&nbsp;                c = _Private_IonConstants.makeUnicodeScalar(c, c2);</b>
<i>2359</i>&nbsp;            }
<i>2360</i>&nbsp;            else {
<i>2361</i>&nbsp;                // we don&#39;t always pair up surrogates here
<i>2362</i>&nbsp;                // our caller does that
<b class="fc"><i>2363</i>&nbsp;                unread_char(c2);</b>
<i>2364</i>&nbsp;            }
<i>2365</i>&nbsp;        }
<b class="fc"><i>2366</i>&nbsp;        return c;</b>
<i>2367</i>&nbsp;    }
<i>2368</i>&nbsp;    private final int read_ut8_sequence(int c) throws IOException
<i>2369</i>&nbsp;    {
<i>2370</i>&nbsp;        // this should have the high order bit set
<b class="fc"><i>2371</i>&nbsp;        assert(!IonTokenConstsX.is7bitValue(c));</b>
<b class="fc"><i>2372</i>&nbsp;        int len = IonUTF8.getUTF8LengthFromFirstByte(c);</b>
<i>2373</i>&nbsp;        int b2, b3, b4;
<b class="fc"><i>2374</i>&nbsp;        switch (len) {</b>
<i>2375</i>&nbsp;        case 1:
<b class="nc"><i>2376</i>&nbsp;            break;</b>
<i>2377</i>&nbsp;        case 2:
<b class="fc"><i>2378</i>&nbsp;            b2 = read_char();</b>
<b class="fc"><i>2379</i>&nbsp;            c = IonUTF8.twoByteScalar(c, b2);</b>
<b class="fc"><i>2380</i>&nbsp;            break;</b>
<i>2381</i>&nbsp;        case 3:
<b class="fc"><i>2382</i>&nbsp;            b2 = read_char();</b>
<b class="fc"><i>2383</i>&nbsp;            b3 = read_char();</b>
<b class="fc"><i>2384</i>&nbsp;            c = IonUTF8.threeByteScalar(c, b2, b3);</b>
<b class="fc"><i>2385</i>&nbsp;            break;</b>
<i>2386</i>&nbsp;        case 4:
<b class="fc"><i>2387</i>&nbsp;            b2 = read_char();</b>
<b class="fc"><i>2388</i>&nbsp;            b3 = read_char();</b>
<b class="fc"><i>2389</i>&nbsp;            b4 = read_char();</b>
<b class="fc"><i>2390</i>&nbsp;            c = IonUTF8.fourByteScalar(c, b2, b3, b4);</b>
<b class="fc"><i>2391</i>&nbsp;            break;</b>
<i>2392</i>&nbsp;        default:
<b class="nc"><i>2393</i>&nbsp;            error(&quot;invalid UTF8 starting byte&quot;);</b>
<i>2394</i>&nbsp;        }
<b class="fc"><i>2395</i>&nbsp;        return c;</b>
<i>2396</i>&nbsp;    }
<i>2397</i>&nbsp;
<i>2398</i>&nbsp;    private void skip_over_blob(SavePoint sp) throws IOException
<i>2399</i>&nbsp;    {
<b class="fc"><i>2400</i>&nbsp;        int c = skip_over_blob_whitespace();</b>
<i>2401</i>&nbsp;        for (;;) {
<b class="fc"><i>2402</i>&nbsp;            if (c == UnifiedInputStreamX.EOF) break;</b>
<b class="fc"><i>2403</i>&nbsp;            if (c == &#39;}&#39;) break;</b>
<b class="fc"><i>2404</i>&nbsp;            c = skip_over_blob_whitespace();</b>
<i>2405</i>&nbsp;        }
<b class="fc"><i>2406</i>&nbsp;        if (sp != null) {</b>
<i>2407</i>&nbsp;            // we don&#39;t care about these last 2 closing curly braces
<i>2408</i>&nbsp;            // but we may have seen one of them already
<b class="fc"><i>2409</i>&nbsp;            int offset = (c == &#39;}&#39;) ? -1 : 0;</b>
<b class="fc"><i>2410</i>&nbsp;            sp.markEnd(offset);</b>
<i>2411</i>&nbsp;        }
<i>2412</i>&nbsp;        // did we hit EOF or the first &#39;}&#39; ?
<b class="fc"><i>2413</i>&nbsp;        if (c != &#39;}&#39;) unexpected_eof();</b>
<b class="fc"><i>2414</i>&nbsp;        c = read_char();</b>
<b class="fc"><i>2415</i>&nbsp;        if (c &lt; 0) {</b>
<b class="fc"><i>2416</i>&nbsp;            unexpected_eof();</b>
<i>2417</i>&nbsp;        }
<b class="fc"><i>2418</i>&nbsp;        if (c != &#39;}&#39;) {</b>
<b class="fc"><i>2419</i>&nbsp;            String message = &quot;improperly closed BLOB, &quot;</b>
<b class="fc"><i>2420</i>&nbsp;                           + IonTextUtils.printCodePointAsString(c)</b>
<i>2421</i>&nbsp;                           + &quot; encountered when &#39;}&#39; was expected&quot;;
<b class="fc"><i>2422</i>&nbsp;            error(message);</b>
<i>2423</i>&nbsp;        }
<b class="fc"><i>2424</i>&nbsp;        if (sp != null) {</b>
<b class="fc"><i>2425</i>&nbsp;            sp.markEnd();</b>
<i>2426</i>&nbsp;        }
<b class="fc"><i>2427</i>&nbsp;        return;</b>
<i>2428</i>&nbsp;    }
<i>2429</i>&nbsp;    protected void load_blob(StringBuilder sb) throws IOException {
<i>2430</i>&nbsp;        int c;
<i>2431</i>&nbsp;
<i>2432</i>&nbsp;        for (;;) {
<b class="nc"><i>2433</i>&nbsp;            c = read_base64_byte();</b>
<b class="nc"><i>2434</i>&nbsp;            if (c == UnifiedInputStreamX.EOF) {</b>
<b class="nc"><i>2435</i>&nbsp;                break;</b>
<i>2436</i>&nbsp;            }
<b class="nc"><i>2437</i>&nbsp;            sb.append(c);</b>
<i>2438</i>&nbsp;        }
<i>2439</i>&nbsp;        // did we hit EOF or the first &#39;}&#39; ?
<b class="nc"><i>2440</i>&nbsp;        if (_stream.isEOF()) unexpected_eof();</b>
<i>2441</i>&nbsp;
<b class="nc"><i>2442</i>&nbsp;        c = read_char();</b>
<b class="nc"><i>2443</i>&nbsp;        if (c &lt; 0) {</b>
<b class="nc"><i>2444</i>&nbsp;            unexpected_eof();</b>
<i>2445</i>&nbsp;        }
<b class="nc"><i>2446</i>&nbsp;        if (c != &#39;}&#39;) {</b>
<b class="nc"><i>2447</i>&nbsp;            String message = &quot;improperly closed BLOB, &quot;</b>
<b class="nc"><i>2448</i>&nbsp;                           + IonTextUtils.printCodePointAsString(c)</b>
<i>2449</i>&nbsp;                           + &quot; encountered when &#39;}&#39; was expected&quot;;
<b class="nc"><i>2450</i>&nbsp;            error(message);</b>
<i>2451</i>&nbsp;        }
<b class="nc"><i>2452</i>&nbsp;        return;</b>
<i>2453</i>&nbsp;    }
<i>2454</i>&nbsp;
<i>2455</i>&nbsp;    private final int read_escaped_char_content_helper(int c1, boolean is_clob)
<i>2456</i>&nbsp;        throws IOException
<i>2457</i>&nbsp;    {
<b class="fc"><i>2458</i>&nbsp;        if (c1 &lt; 0) {</b>
<b class="nc"><i>2459</i>&nbsp;            switch (c1) {</b>
<i>2460</i>&nbsp;            // new line normalization and counting is handled in read_char
<i>2461</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
<b class="nc"><i>2462</i>&nbsp;                return CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1;</b>
<i>2463</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
<b class="nc"><i>2464</i>&nbsp;                return CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2;</b>
<i>2465</i>&nbsp;            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
<b class="nc"><i>2466</i>&nbsp;                return CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3;</b>
<i>2467</i>&nbsp;            default:
<b class="nc"><i>2468</i>&nbsp;                bad_escape_sequence(c1);</b>
<i>2469</i>&nbsp;            }
<i>2470</i>&nbsp;        }
<b class="fc"><i>2471</i>&nbsp;        if (!IonTokenConstsX.isValidEscapeStart(c1)) {</b>
<b class="fc"><i>2472</i>&nbsp;            bad_escape_sequence(c1);</b>
<i>2473</i>&nbsp;        }
<b class="fc"><i>2474</i>&nbsp;        int c2 = IonTokenConstsX.escapeReplacementCharacter(c1);</b>
<b class="fc"><i>2475</i>&nbsp;        switch (c2) {</b>
<i>2476</i>&nbsp;        case IonTokenConstsX.ESCAPE_NOT_DEFINED:
<b class="nc"><i>2477</i>&nbsp;            assert false</b>
<i>2478</i>&nbsp;                : &quot;invalid escape start characters (line &quot; + ((char)c1)
<i>2479</i>&nbsp;                + &quot; should have been removed by isValid&quot;;
<i>2480</i>&nbsp;            break;
<i>2481</i>&nbsp;        case IonTokenConstsX.ESCAPE_LITTLE_U:
<b class="fc"><i>2482</i>&nbsp;            if (is_clob) {</b>
<b class="fc"><i>2483</i>&nbsp;                bad_escape_sequence(c2);</b>
<i>2484</i>&nbsp;            }
<b class="fc"><i>2485</i>&nbsp;            c2 = read_hex_escape_sequence_value(4);</b>
<b class="fc"><i>2486</i>&nbsp;            break;</b>
<i>2487</i>&nbsp;        case IonTokenConstsX.ESCAPE_BIG_U:
<b class="fc"><i>2488</i>&nbsp;            if (is_clob) {</b>
<b class="fc"><i>2489</i>&nbsp;                bad_escape_sequence(c2);</b>
<i>2490</i>&nbsp;            }
<b class="fc"><i>2491</i>&nbsp;            c2 = read_hex_escape_sequence_value(8);</b>
<b class="fc"><i>2492</i>&nbsp;            break;</b>
<i>2493</i>&nbsp;        case IonTokenConstsX.ESCAPE_HEX:
<b class="fc"><i>2494</i>&nbsp;            c2 = read_hex_escape_sequence_value(2);</b>
<i>2495</i>&nbsp;            break;
<i>2496</i>&nbsp;        }
<b class="fc"><i>2497</i>&nbsp;        return c2;</b>
<i>2498</i>&nbsp;    }
<i>2499</i>&nbsp;    private final int read_hex_escape_sequence_value(int len) throws IOException
<i>2500</i>&nbsp;    {
<b class="fc"><i>2501</i>&nbsp;        int hexchar = 0;</b>
<b class="fc"><i>2502</i>&nbsp;        while (len &gt; 0) {</b>
<b class="fc"><i>2503</i>&nbsp;            len--;</b>
<b class="fc"><i>2504</i>&nbsp;            int c = read_char();</b>
<b class="fc"><i>2505</i>&nbsp;            if (c &lt; 0) {</b>
<b class="nc"><i>2506</i>&nbsp;                unexpected_eof();</b>
<i>2507</i>&nbsp;            }
<b class="fc"><i>2508</i>&nbsp;            int d = IonTokenConstsX.hexDigitValue(c);</b>
<b class="fc"><i>2509</i>&nbsp;            if (d &lt; 0) return -1;</b>
<b class="fc"><i>2510</i>&nbsp;            hexchar = (hexchar &lt;&lt; 4) + d;</b>
<b class="fc"><i>2511</i>&nbsp;        }</b>
<b class="fc"><i>2512</i>&nbsp;        if (len &gt; 0) {</b>
<b class="nc"><i>2513</i>&nbsp;            String message = &quot;invalid hex digit [&quot;</b>
<b class="nc"><i>2514</i>&nbsp;                + IonTextUtils.printCodePointAsString(hexchar)</b>
<i>2515</i>&nbsp;                + &quot;] in escape sequence&quot;;
<b class="nc"><i>2516</i>&nbsp;            error(message);</b>
<i>2517</i>&nbsp;        }
<b class="fc"><i>2518</i>&nbsp;        return hexchar;</b>
<i>2519</i>&nbsp;    }
<i>2520</i>&nbsp;
<i>2521</i>&nbsp;    public final int read_base64_byte() throws IOException
<i>2522</i>&nbsp;    {
<i>2523</i>&nbsp;        int b;
<b class="fc"><i>2524</i>&nbsp;        if (_base64_prefetch_count &lt; 1) {</b>
<b class="fc"><i>2525</i>&nbsp;            b = read_base64_byte_helper();</b>
<i>2526</i>&nbsp;        }
<i>2527</i>&nbsp;        else {
<b class="fc"><i>2528</i>&nbsp;            b = (_base64_prefetch_stack &amp; 0xff);</b>
<b class="fc"><i>2529</i>&nbsp;            _base64_prefetch_stack &gt;&gt;= 8;</b>
<b class="fc"><i>2530</i>&nbsp;            _base64_prefetch_count--;</b>
<i>2531</i>&nbsp;        }
<b class="fc"><i>2532</i>&nbsp;        return b;</b>
<i>2533</i>&nbsp;    }
<i>2534</i>&nbsp;    private final int read_base64_byte_helper() throws IOException
<i>2535</i>&nbsp;    {
<i>2536</i>&nbsp;        // if there&#39;s any data left to read (the normal case)
<i>2537</i>&nbsp;        // we&#39;ll read 4 characters off the input source and
<i>2538</i>&nbsp;        // generate 1-3 bytes to return to the user.  That
<i>2539</i>&nbsp;        // will be 1 byte returned immediately and 0-2 bytes
<i>2540</i>&nbsp;        // put on the _binhex_stack to return later
<i>2541</i>&nbsp;
<b class="fc"><i>2542</i>&nbsp;        int c = skip_over_blob_whitespace();</b>
<b class="fc"><i>2543</i>&nbsp;        if (c == UnifiedInputStreamX.EOF || c == &#39;}&#39;) {</b>
<i>2544</i>&nbsp;            // we&#39;ll figure how which is which by check the stream for eof
<b class="fc"><i>2545</i>&nbsp;            return UnifiedInputStreamX.EOF;</b>
<i>2546</i>&nbsp;        }
<i>2547</i>&nbsp;
<b class="fc"><i>2548</i>&nbsp;        int c1 = read_base64_getchar_helper(c);</b>
<b class="fc"><i>2549</i>&nbsp;        int c2 = read_base64_getchar_helper();</b>
<b class="fc"><i>2550</i>&nbsp;        int c3 = read_base64_getchar_helper();</b>
<b class="fc"><i>2551</i>&nbsp;        int c4 = read_base64_getchar_helper();</b>
<i>2552</i>&nbsp;
<b class="fc"><i>2553</i>&nbsp;        int b1, len = decode_base64_length(c1, c2, c3, c4);</b>
<i>2554</i>&nbsp;
<b class="fc"><i>2555</i>&nbsp;        _base64_prefetch_stack = 0;</b>
<b class="fc"><i>2556</i>&nbsp;        _base64_prefetch_count = len - 1;</b>
<b class="fc"><i>2557</i>&nbsp;        switch (len) {</b>
<i>2558</i>&nbsp;        default:
<b class="nc"><i>2559</i>&nbsp;            String message =</b>
<b class="nc"><i>2560</i>&nbsp;                &quot;invalid binhex sequence encountered at offset&quot;+input_position();</b>
<b class="nc"><i>2561</i>&nbsp;            throw new IonReaderTextTokenException(message);</b>
<i>2562</i>&nbsp;        case 3:
<b class="fc"><i>2563</i>&nbsp;            int b3  = decode_base64_byte3(c1, c2, c3, c4);</b>
<b class="fc"><i>2564</i>&nbsp;            _base64_prefetch_stack = (b3 &lt;&lt; 8) &amp; 0xff00;</b>
<i>2565</i>&nbsp;            // fall through
<i>2566</i>&nbsp;        case 2:
<b class="fc"><i>2567</i>&nbsp;            int b2  = decode_base64_byte2(c1, c2, c3, c4);</b>
<b class="fc"><i>2568</i>&nbsp;            _base64_prefetch_stack |= (b2 &amp; 0xff);</b>
<i>2569</i>&nbsp;            // fall through
<i>2570</i>&nbsp;        case 1:
<b class="fc"><i>2571</i>&nbsp;            b1 = decode_base64_byte1(c1, c2, c3, c4);</b>
<i>2572</i>&nbsp;            // fall through
<i>2573</i>&nbsp;        }
<b class="fc"><i>2574</i>&nbsp;        return b1;</b>
<i>2575</i>&nbsp;    }
<i>2576</i>&nbsp;    private final int read_base64_getchar_helper(int c) throws IOException {
<b class="fc"><i>2577</i>&nbsp;        assert( ! (c == UnifiedInputStreamX.EOF || c == &#39;}&#39;) );</b>
<i>2578</i>&nbsp;
<b class="fc"><i>2579</i>&nbsp;        if (c == UnifiedInputStreamX.EOF || c == &#39;}&#39;) {</b>
<b class="nc"><i>2580</i>&nbsp;            return UnifiedInputStreamX.EOF;</b>
<i>2581</i>&nbsp;        }
<b class="fc"><i>2582</i>&nbsp;        if (c == BASE64_TERMINATOR_CHAR) {</b>
<b class="fc"><i>2583</i>&nbsp;            error(&quot;invalid base64 image - excess terminator characters [&#39;=&#39;]&quot;);</b>
<i>2584</i>&nbsp;        }
<b class="fc"><i>2585</i>&nbsp;        return read_base64_getchar_helper2(c);</b>
<i>2586</i>&nbsp;    }
<i>2587</i>&nbsp;    private final int read_base64_getchar_helper() throws IOException {
<b class="fc"><i>2588</i>&nbsp;        int c = skip_over_blob_whitespace();</b>
<b class="fc"><i>2589</i>&nbsp;        if (c == UnifiedInputStreamX.EOF || c == &#39;}&#39;) {</b>
<b class="fc"><i>2590</i>&nbsp;            error(&quot;invalid base64 image - too short&quot;);</b>
<i>2591</i>&nbsp;        }
<b class="fc"><i>2592</i>&nbsp;        return read_base64_getchar_helper2(c);</b>
<i>2593</i>&nbsp;    }
<i>2594</i>&nbsp;    private final int read_base64_getchar_helper2(int c) throws IOException {
<b class="fc"><i>2595</i>&nbsp;        assert( ! (c == UnifiedInputStreamX.EOF || c == &#39;}&#39;) );</b>
<i>2596</i>&nbsp;
<b class="fc"><i>2597</i>&nbsp;        if (c == BASE64_TERMINATOR_CHAR) {</b>
<i>2598</i>&nbsp;            // we&#39;re using a new EOF here since the &#39;=&#39; is in range
<i>2599</i>&nbsp;            // of 0-63 (6 bits) and we don&#39;t want to confuse it with
<i>2600</i>&nbsp;            // the normal EOF
<b class="fc"><i>2601</i>&nbsp;            return BASE64_EOF;</b>
<i>2602</i>&nbsp;        }
<b class="fc"><i>2603</i>&nbsp;        int b = BASE64_CHAR_TO_BIN[c &amp; 0xff];</b>
<b class="fc"><i>2604</i>&nbsp;        if (b == UnifiedInputStreamX.EOF || !IonTokenConstsX.is8bitValue(c)) {</b>
<b class="fc"><i>2605</i>&nbsp;            String message = &quot;invalid character &quot;</b>
<b class="fc"><i>2606</i>&nbsp;                           + Character.toString((char)c)</b>
<i>2607</i>&nbsp;                           + &quot; encountered in base64 value at &quot;
<b class="fc"><i>2608</i>&nbsp;                           + input_position();</b>
<b class="fc"><i>2609</i>&nbsp;            throw new IonReaderTextTokenException(message);</b>
<i>2610</i>&nbsp;        }
<b class="fc"><i>2611</i>&nbsp;        return b;</b>
<i>2612</i>&nbsp;    }
<i>2613</i>&nbsp;    private final static int decode_base64_length(int c1, int c2, int c3, int c4) {
<b class="fc"><i>2614</i>&nbsp;        int len = 3;</b>
<b class="fc"><i>2615</i>&nbsp;        if (c4 != BASE64_EOF)      len = 3;</b>
<b class="fc"><i>2616</i>&nbsp;        else if (c3 != BASE64_EOF) len = 2;</b>
<b class="fc"><i>2617</i>&nbsp;        else                       len = 1;</b>
<b class="fc"><i>2618</i>&nbsp;        return len;</b>
<i>2619</i>&nbsp;    }
<i>2620</i>&nbsp;    private final static int decode_base64_byte1(int c1, int c2, int c3, int c4) {
<i>2621</i>&nbsp;        //extracted from Base64Encoder.java:
<i>2622</i>&nbsp;        // convert =  c1 &lt;&lt; 18;    [6:1] + 18 =&gt; [24:19]
<i>2623</i>&nbsp;        // convert |= (c2 &lt;&lt; 12);  [6:1] + 12 =&gt; [18:13]
<i>2624</i>&nbsp;        // b1 = (char)((convert &amp; 0x00FF0000) &gt;&gt; 16);  [32:1] &amp; 0x00FF0000 =&gt; [24:17] - 16 =&gt; [8:1]
<i>2625</i>&nbsp;        // byte1 uses the 6 bits in char1 + 2 highest bits (out of 6) from char2
<i>2626</i>&nbsp;        if (_debug) assert(decode_base64_length(c1, c2, c3, c4) &gt;= 1);
<b class="fc"><i>2627</i>&nbsp;        int b1 = (((c1 &lt;&lt; 2) &amp; 0xfc) | ((c2 &gt;&gt; 4) &amp; 0x03));</b>
<b class="fc"><i>2628</i>&nbsp;        return b1;</b>
<i>2629</i>&nbsp;    }
<i>2630</i>&nbsp;    private final static int decode_base64_byte2(int c1, int c2, int c3, int c4) {
<i>2631</i>&nbsp;        //convert |= (c2 &lt;&lt; 12);  [6:1]+12 =&gt; [18:13]
<i>2632</i>&nbsp;        //convert |= (c3 &lt;&lt; 6);   [6:1]+6  =&gt; [12:7]
<i>2633</i>&nbsp;        //b2 = (char)((convert &amp; 0x0000FF00) &gt;&gt; 8); [32:1] &amp; 0x0000FF00 =&gt; [16:9] - 8 =&gt; [8:1]
<i>2634</i>&nbsp;        // [18:13] - 8 -&gt; [10:5] or [6:5] from c2
<i>2635</i>&nbsp;        // [12:7] - 8 -&gt; [4:-1] or [6:3] - 2 from c3
<i>2636</i>&nbsp;        //byte2 uses 4 low bits from c2 and 4 high bits from c3
<i>2637</i>&nbsp;        if (_debug) assert(decode_base64_length(c1, c2, c3, c4) &gt;= 2);
<b class="fc"><i>2638</i>&nbsp;        int b2 = (((c2 &lt;&lt; 4) &amp; 0xf0) | ((c3 &gt;&gt; 2) &amp; 0x0f)) &amp; 0xff;</b>
<b class="fc"><i>2639</i>&nbsp;        return b2;</b>
<i>2640</i>&nbsp;    }
<i>2641</i>&nbsp;    private final static int decode_base64_byte3(int c1, int c2, int c3, int c4) {
<i>2642</i>&nbsp;        // convert |= (c3 &lt;&lt; 6); [6:1]+6  =&gt; [12:7]
<i>2643</i>&nbsp;        // convert |= (c4 &lt;&lt; 0); [6:1]+9  =&gt; [6:1]
<i>2644</i>&nbsp;        // b3 = (char)((convert &amp; 0x000000FF) &gt;&gt; 0);
<i>2645</i>&nbsp;        // b3 uses low 2 bits from c3 and all 6 bits of c4
<i>2646</i>&nbsp;        if (_debug) assert(decode_base64_length(c1, c2, c3, c4) &gt;= 3);
<b class="fc"><i>2647</i>&nbsp;        int b3 = (((c3 &amp; 0x03) &lt;&lt; 6) | (c4 &amp; 0x3f)) &amp; 0xff;</b>
<b class="fc"><i>2648</i>&nbsp;        return b3;</b>
<i>2649</i>&nbsp;    }
<i>2650</i>&nbsp;
<i>2651</i>&nbsp;    protected void save_point_start(SavePoint sp) throws IOException
<i>2652</i>&nbsp;    {
<b class="fc"><i>2653</i>&nbsp;        assert(sp != null &amp;&amp; sp.isClear());</b>
<b class="fc"><i>2654</i>&nbsp;        long line_number = _line_count;</b>
<b class="fc"><i>2655</i>&nbsp;        long line_start = _line_starting_position;</b>
<b class="fc"><i>2656</i>&nbsp;        sp.start(line_number, line_start);</b>
<b class="fc"><i>2657</i>&nbsp;    }</b>
<i>2658</i>&nbsp;    protected void save_point_activate(SavePoint sp) throws IOException
<i>2659</i>&nbsp;    {
<b class="fc"><i>2660</i>&nbsp;        assert(sp != null &amp;&amp; sp.isDefined());</b>
<b class="fc"><i>2661</i>&nbsp;        long line_number = _line_count;</b>
<b class="fc"><i>2662</i>&nbsp;        long line_start  = _line_starting_position;</b>
<i>2663</i>&nbsp;        // this will set the &quot;restore&quot; (aka prev) line and start offset so
<i>2664</i>&nbsp;        // that when we pop the save point we&#39;ll get the correct line &amp; char
<b class="fc"><i>2665</i>&nbsp;        _stream._save_points.savePointPushActive(sp, line_number, line_start);</b>
<b class="fc"><i>2666</i>&nbsp;        _line_count = sp.getStartLineNumber();</b>
<b class="fc"><i>2667</i>&nbsp;        _line_starting_position = sp.getStartLineStart();</b>
<b class="fc"><i>2668</i>&nbsp;    }</b>
<i>2669</i>&nbsp;    protected void save_point_deactivate(SavePoint sp) throws IOException
<i>2670</i>&nbsp;    {
<b class="fc"><i>2671</i>&nbsp;        assert(sp != null &amp;&amp; sp.isActive());</b>
<i>2672</i>&nbsp;
<b class="fc"><i>2673</i>&nbsp;        _stream._save_points.savePointPopActive(sp);</b>
<b class="fc"><i>2674</i>&nbsp;        _line_count = sp.getPrevLineNumber();</b>
<b class="fc"><i>2675</i>&nbsp;        _line_starting_position = sp.getPrevLineStart();</b>
<b class="fc"><i>2676</i>&nbsp;    }</b>
<i>2677</i>&nbsp;
<i>2678</i>&nbsp;    protected final void error(String message)
<i>2679</i>&nbsp;    {
<b class="fc"><i>2680</i>&nbsp;        String message2 = message + input_position();</b>
<b class="fc"><i>2681</i>&nbsp;        throw new IonReaderTextTokenException(message2);</b>
<i>2682</i>&nbsp;    }
<i>2683</i>&nbsp;    protected final void unexpected_eof()
<i>2684</i>&nbsp;    {
<b class="fc"><i>2685</i>&nbsp;        String message = &quot;unexpected EOF encountered &quot;+input_position();</b>
<b class="fc"><i>2686</i>&nbsp;        throw new UnexpectedEofException(message);</b>
<i>2687</i>&nbsp;    }
<i>2688</i>&nbsp;    protected final void bad_escape_sequence()
<i>2689</i>&nbsp;    {
<b class="nc"><i>2690</i>&nbsp;        String message = &quot;bad escape character encountered &quot;+input_position();</b>
<b class="nc"><i>2691</i>&nbsp;        throw new IonReaderTextTokenException(message);</b>
<i>2692</i>&nbsp;    }
<i>2693</i>&nbsp;    protected final void bad_escape_sequence(int c)
<i>2694</i>&nbsp;    {
<b class="fc"><i>2695</i>&nbsp;        String message =</b>
<b class="fc"><i>2696</i>&nbsp;            &quot;bad escape character &#39;&quot;+printCodePointAsString(c)+</b>
<b class="fc"><i>2697</i>&nbsp;            &quot;&#39; encountered &quot;+input_position();</b>
<b class="fc"><i>2698</i>&nbsp;        throw new IonReaderTextTokenException(message);</b>
<i>2699</i>&nbsp;    }
<i>2700</i>&nbsp;    protected final void bad_token_start(int c)
<i>2701</i>&nbsp;    {
<b class="fc"><i>2702</i>&nbsp;        String message =</b>
<b class="fc"><i>2703</i>&nbsp;            &quot;bad character [&quot;+c+&quot;, &quot;+printCodePointAsString(c)+</b>
<i>2704</i>&nbsp;            &quot;] encountered where a token was supposed to start &quot;+
<b class="fc"><i>2705</i>&nbsp;            input_position();</b>
<b class="fc"><i>2706</i>&nbsp;        throw new IonReaderTextTokenException(message);</b>
<i>2707</i>&nbsp;    }
<i>2708</i>&nbsp;    protected final void bad_token(int c)
<i>2709</i>&nbsp;    {
<b class="fc"><i>2710</i>&nbsp;        String charStr = IonTextUtils.printCodePointAsString(c);</b>
<b class="fc"><i>2711</i>&nbsp;        String message =</b>
<b class="fc"><i>2712</i>&nbsp;            &quot;a bad character &quot; + charStr + &quot; was encountered &quot;+input_position();</b>
<b class="fc"><i>2713</i>&nbsp;        throw new IonReaderTextTokenException(message);</b>
<i>2714</i>&nbsp;    }
<i>2715</i>&nbsp;
<i>2716</i>&nbsp;    protected final void expected_but_found(String expected, int c)
<i>2717</i>&nbsp;    {
<b class="fc"><i>2718</i>&nbsp;        String charStr = IonTextUtils.printCodePointAsString(c);</b>
<b class="fc"><i>2719</i>&nbsp;        String message =</b>
<b class="fc"><i>2720</i>&nbsp;            &quot;Expected &quot; + expected + &quot; but found &quot; + charStr + input_position();</b>
<b class="fc"><i>2721</i>&nbsp;        throw new IonReaderTextTokenException(message);</b>
<i>2722</i>&nbsp;    }
<i>2723</i>&nbsp;
<i>2724</i>&nbsp;    static public class IonReaderTextTokenException extends IonException {
<i>2725</i>&nbsp;        private static final long serialVersionUID = 1L;
<i>2726</i>&nbsp;        IonReaderTextTokenException(String msg) {
<b class="fc"><i>2727</i>&nbsp;            super(msg);</b>
<b class="fc"><i>2728</i>&nbsp;        }</b>
<i>2729</i>&nbsp;    }
<i>2730</i>&nbsp;
<b class="fc"><i>2731</i>&nbsp;    private enum ProhibitedCharacters {</b>
<b class="fc"><i>2732</i>&nbsp;        SHORT_CHAR</b>
<i>2733</i>&nbsp;        {
<i>2734</i>&nbsp;            boolean includes(int c)
<i>2735</i>&nbsp;            {
<b class="fc"><i>2736</i>&nbsp;                return isControlCharacter(c) &amp;&amp; !isWhitespace(c);</b>
<i>2737</i>&nbsp;            }
<i>2738</i>&nbsp;        },
<i>2739</i>&nbsp;
<b class="fc"><i>2740</i>&nbsp;        LONG_CHAR</b>
<i>2741</i>&nbsp;        {
<i>2742</i>&nbsp;            boolean includes(int c)
<i>2743</i>&nbsp;            {
<b class="fc"><i>2744</i>&nbsp;                return isControlCharacter(c) &amp;&amp; !isWhitespace(c) &amp;&amp; !isNewline(c);</b>
<i>2745</i>&nbsp;            }
<i>2746</i>&nbsp;        },
<i>2747</i>&nbsp;
<b class="fc"><i>2748</i>&nbsp;        NONE</b>
<i>2749</i>&nbsp;        {
<i>2750</i>&nbsp;            boolean includes(int c)
<i>2751</i>&nbsp;            {
<b class="fc"><i>2752</i>&nbsp;                return false;</b>
<i>2753</i>&nbsp;            }
<i>2754</i>&nbsp;        };
<i>2755</i>&nbsp;
<i>2756</i>&nbsp;        abstract boolean includes(int c);
<i>2757</i>&nbsp;
<i>2758</i>&nbsp;        private static boolean isControlCharacter(int c)
<i>2759</i>&nbsp;        {
<b class="fc"><i>2760</i>&nbsp;            return c &lt;= 0x1F &amp;&amp; 0x00 &lt;= c;</b>
<i>2761</i>&nbsp;        }
<i>2762</i>&nbsp;
<i>2763</i>&nbsp;        private static boolean isNewline(int c)
<i>2764</i>&nbsp;        {
<b class="fc"><i>2765</i>&nbsp;            return c == 0x0A || c == 0x0D;</b>
<i>2766</i>&nbsp;        }
<i>2767</i>&nbsp;
<i>2768</i>&nbsp;        private static boolean isWhitespace(int c)
<i>2769</i>&nbsp;        {
<b class="fc"><i>2770</i>&nbsp;            return c == 0x09 // tab</b>
<i>2771</i>&nbsp;                || c == 0x0B // vertical tab
<i>2772</i>&nbsp;                || c == 0x0C // form feed
<i>2773</i>&nbsp;                || c == 0x20 // space
<i>2774</i>&nbsp;            ;
<i>2775</i>&nbsp;        }
<i>2776</i>&nbsp;    }
<i>2777</i>&nbsp;
<b class="fc"><i>2778</i>&nbsp;    private enum Radix</b>
<i>2779</i>&nbsp;    {
<b class="fc"><i>2780</i>&nbsp;        BINARY</b>
<i>2781</i>&nbsp;        {
<i>2782</i>&nbsp;            boolean isPrefix(int c)
<i>2783</i>&nbsp;            {
<b class="fc"><i>2784</i>&nbsp;                return c == &#39;b&#39; || c == &#39;B&#39;;</b>
<i>2785</i>&nbsp;            }
<i>2786</i>&nbsp;
<i>2787</i>&nbsp;            boolean isValidDigit(int c)
<i>2788</i>&nbsp;            {
<b class="fc"><i>2789</i>&nbsp;                return IonTokenConstsX.isBinaryDigit(c);</b>
<i>2790</i>&nbsp;            }
<i>2791</i>&nbsp;
<i>2792</i>&nbsp;            @Override
<i>2793</i>&nbsp;            char normalizeDigit(char c)
<i>2794</i>&nbsp;            {
<b class="fc"><i>2795</i>&nbsp;                return c; // no normalization required</b>
<i>2796</i>&nbsp;            }
<i>2797</i>&nbsp;        },
<i>2798</i>&nbsp;
<b class="fc"><i>2799</i>&nbsp;        DECIMAL</b>
<i>2800</i>&nbsp;        {
<i>2801</i>&nbsp;            boolean isPrefix(int c)
<i>2802</i>&nbsp;            {
<b class="nc"><i>2803</i>&nbsp;                return false;</b>
<i>2804</i>&nbsp;            }
<i>2805</i>&nbsp;
<i>2806</i>&nbsp;            boolean isValidDigit(int c)
<i>2807</i>&nbsp;            {
<b class="fc"><i>2808</i>&nbsp;                return IonTokenConstsX.isDigit(c);</b>
<i>2809</i>&nbsp;            }
<i>2810</i>&nbsp;
<i>2811</i>&nbsp;            @Override
<i>2812</i>&nbsp;            char normalizeDigit(char c)
<i>2813</i>&nbsp;            {
<b class="fc"><i>2814</i>&nbsp;                return c; // no normalization required</b>
<i>2815</i>&nbsp;            }
<i>2816</i>&nbsp;        },
<i>2817</i>&nbsp;
<b class="fc"><i>2818</i>&nbsp;        HEX</b>
<i>2819</i>&nbsp;        {
<i>2820</i>&nbsp;            boolean isPrefix(int c)
<i>2821</i>&nbsp;            {
<b class="fc"><i>2822</i>&nbsp;                return c == &#39;x&#39; || c == &#39;X&#39;;</b>
<i>2823</i>&nbsp;            }
<i>2824</i>&nbsp;
<i>2825</i>&nbsp;            boolean isValidDigit(int c)
<i>2826</i>&nbsp;            {
<b class="fc"><i>2827</i>&nbsp;                return IonTokenConstsX.isHexDigit(c);</b>
<i>2828</i>&nbsp;            }
<i>2829</i>&nbsp;
<i>2830</i>&nbsp;            @Override
<i>2831</i>&nbsp;            char normalizeDigit(char c)
<i>2832</i>&nbsp;            {
<b class="fc"><i>2833</i>&nbsp;                return Character.toLowerCase(c);</b>
<i>2834</i>&nbsp;            }
<i>2835</i>&nbsp;        };
<i>2836</i>&nbsp;
<i>2837</i>&nbsp;        abstract boolean isPrefix(int c);
<i>2838</i>&nbsp;        abstract boolean isValidDigit(int c);
<i>2839</i>&nbsp;        abstract char normalizeDigit(char c);
<i>2840</i>&nbsp;
<i>2841</i>&nbsp;        void assertPrefix(int c)
<i>2842</i>&nbsp;        {
<b class="fc"><i>2843</i>&nbsp;            assert isPrefix(c);</b>
<b class="fc"><i>2844</i>&nbsp;        }</b>
<i>2845</i>&nbsp;    }
<i>2846</i>&nbsp;
<i>2847</i>&nbsp;    private int readNumeric(Appendable buffer, Radix radix) throws IOException
<i>2848</i>&nbsp;    {
<b class="fc"><i>2849</i>&nbsp;        return readNumeric(buffer, radix, NumericState.START);</b>
<i>2850</i>&nbsp;    }
<i>2851</i>&nbsp;
<i>2852</i>&nbsp;    private int readNumeric(Appendable buffer, Radix radix, NumericState startingState) throws IOException
<i>2853</i>&nbsp;    {
<b class="fc"><i>2854</i>&nbsp;        NumericState state = startingState;</b>
<i>2855</i>&nbsp;
<i>2856</i>&nbsp;        for (;;)
<i>2857</i>&nbsp;        {
<b class="fc"><i>2858</i>&nbsp;            int c = read_char();</b>
<b class="fc"><i>2859</i>&nbsp;            switch (state)</b>
<i>2860</i>&nbsp;            {
<i>2861</i>&nbsp;                case START:
<b class="fc"><i>2862</i>&nbsp;                    if (radix.isValidDigit(c))</b>
<i>2863</i>&nbsp;                    {
<b class="fc"><i>2864</i>&nbsp;                        buffer.append(radix.normalizeDigit((char) c));</b>
<b class="fc"><i>2865</i>&nbsp;                        state = NumericState.DIGIT;</b>
<i>2866</i>&nbsp;                    }
<i>2867</i>&nbsp;                    else
<i>2868</i>&nbsp;                    {
<b class="fc"><i>2869</i>&nbsp;                        return c;</b>
<i>2870</i>&nbsp;                    }
<i>2871</i>&nbsp;                    break;
<i>2872</i>&nbsp;                case DIGIT:
<b class="fc"><i>2873</i>&nbsp;                    if (radix.isValidDigit(c))</b>
<i>2874</i>&nbsp;                    {
<b class="fc"><i>2875</i>&nbsp;                        buffer.append(radix.normalizeDigit((char) c));</b>
<b class="fc"><i>2876</i>&nbsp;                        state = NumericState.DIGIT;</b>
<i>2877</i>&nbsp;                    }
<b class="fc"><i>2878</i>&nbsp;                    else if (c == &#39;_&#39;)</b>
<i>2879</i>&nbsp;                    {
<b class="fc"><i>2880</i>&nbsp;                        state = NumericState.UNDERSCORE;</b>
<i>2881</i>&nbsp;                    }
<i>2882</i>&nbsp;                    else
<i>2883</i>&nbsp;                    {
<b class="fc"><i>2884</i>&nbsp;                        return c;</b>
<i>2885</i>&nbsp;                    }
<i>2886</i>&nbsp;                    break;
<i>2887</i>&nbsp;                case UNDERSCORE:
<b class="fc"><i>2888</i>&nbsp;                    if (radix.isValidDigit(c))</b>
<i>2889</i>&nbsp;                    {
<b class="fc"><i>2890</i>&nbsp;                        buffer.append(radix.normalizeDigit((char) c));</b>
<b class="fc"><i>2891</i>&nbsp;                        state = NumericState.DIGIT;</b>
<i>2892</i>&nbsp;                    }
<i>2893</i>&nbsp;                    else
<i>2894</i>&nbsp;                    {
<b class="fc"><i>2895</i>&nbsp;                        unread_char(c);</b>
<b class="fc"><i>2896</i>&nbsp;                        return &#39;_&#39;;</b>
<i>2897</i>&nbsp;                    }
<i>2898</i>&nbsp;                    break;
<i>2899</i>&nbsp;            }
<b class="fc"><i>2900</i>&nbsp;        }</b>
<i>2901</i>&nbsp;    }
<i>2902</i>&nbsp;
<b class="fc"><i>2903</i>&nbsp;    private enum NumericState</b>
<i>2904</i>&nbsp;    {
<b class="fc"><i>2905</i>&nbsp;        START,</b>
<b class="fc"><i>2906</i>&nbsp;        UNDERSCORE,</b>
<b class="fc"><i>2907</i>&nbsp;        DIGIT,</b>
<i>2908</i>&nbsp;    }
<i>2909</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2021-02-15 21:53</div>
</div>
</body>
</html>
